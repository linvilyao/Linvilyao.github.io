<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"linvilyao.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Welcome to Linvil&#39;s Blog!">
<meta property="og:type" content="website">
<meta property="og:title" content="Linvil&#39;s Blog">
<meta property="og:url" content="http://linvilyao.github.io/index.html">
<meta property="og:site_name" content="Linvil&#39;s Blog">
<meta property="og:description" content="Welcome to Linvil&#39;s Blog!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Linvil Yao">
<meta property="article:tag" content="研究牲">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://linvilyao.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linvil's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Linvil's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">这是一个用来记录的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Linvil Yao"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Linvil Yao</p>
  <div class="site-description" itemprop="description">Welcome to Linvil's Blog!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/linvilyao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;linvilyao" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">深度学习模型之CNN卷积神经网络（一）CNN原理概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-25 22:36:25 / 修改时间：23:44:44" itemprop="dateCreated datePublished" datetime="2023-04-25T22:36:25+08:00">2023-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
        </span>
    </span>

  
    <span id="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/" class="post-meta-item leancloud_visitors" data-flag-title="深度学习模型之CNN卷积神经网络（一）CNN原理概述" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="卷积神经网络的架构"><a href="#卷积神经网络的架构" class="headerlink" title="卷积神经网络的架构"></a><strong>卷积神经网络的架构</strong></h1><p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积神经网络的架构.png" alt="卷积神经网络的架构" style="zoom:80%;"></p>
<h1 id="卷积神经网络（CNN）解决了什么问题？"><a href="#卷积神经网络（CNN）解决了什么问题？" class="headerlink" title="卷积神经网络（CNN）解决了什么问题？"></a><strong>卷积神经网络（CNN）解决了什么问题？</strong></h1><p>CNN，是近年发展起来的并引起广泛重视的一种高效识别方法，可以说是深度学习算法应用最成功的领域之一，其价值在于能够将大数据量的图片有效地降维城小数据量且不影响结果，同时与人类视觉原理类似，CNN能够较完整地保留图片的特征。</p>
<p>卷积神经网络包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。一维卷积神经网络主要用于序列类的数据处理，二维卷积神经网络常应用于图像类文本的识别，三维卷积神经网络主要应用于医学图像以及视频类数据识别。</p>
<p>在 CNN 出现之前，图像对于人工智能来说一直是一个难题，问题的主要原因有2个：</p>
<ul>
<li><strong>需要处理的数据量太大</strong></li>
<li><strong>保留图像特征</strong></li>
</ul>
<p><strong>需要处理的数据量太大</strong></p>
<p>图像是由每个带有颜色的像素构成的，且每个像素都有RGB（可简单理解为光学三原色：红、绿、蓝）3个参数来表示颜色信息。</p>
<p>假如现在需要处理一张1000<em>1000像素的图片，就需要处理1000</em>1000*3=3，000，000个参数！如此大量的数据处理起来是非常消耗资源的，而且这还只是一张不算太大的图片。</p>
<p><strong>保留图像特征</strong></p>
<p>假如将一张图片划分为四个区域，其中一个区域中有圆形表示为数字1，没有圆形则表示为0，那么圆形的位置不同就会产生完全不同的数据表达，上述的这个过程就相当于是传统的图片数字化过程简化版。</p>
<p>对于上述两个问题，CNN通过将复杂问题简化和保留图像特征就较为完美地解决了，那么，CNN是如何进行实现的呢？</p>
<h1 id="卷积神经网络（CNN）的基本原理"><a href="#卷积神经网络（CNN）的基本原理" class="headerlink" title="卷积神经网络（CNN）的基本原理"></a><strong>卷积神经网络（CNN）的基本原理</strong></h1><h2 id="卷积神经网络的层级结构"><a href="#卷积神经网络的层级结构" class="headerlink" title="卷积神经网络的层级结构"></a><strong>卷积神经网络的层级结构</strong></h2><p>一个卷积神经网络主要由以下 5 层组成：</p>
<ul>
<li>数据输入层/ Input layer</li>
<li>卷积计算层/ CONV layer</li>
<li>ReLU 激励层 / ReLU layer</li>
<li>池化层 / Pooling layer</li>
<li>全连接层 / FC layer</li>
</ul>
<h3 id="数据输入层"><a href="#数据输入层" class="headerlink" title="数据输入层"></a>数据输入层</h3><p>该层要做的处理主要是对原始图像数据进行预处理，其中包括：</p>
<ul>
<li><strong>去均值</strong>：把输入数据各个维度都中心化为 0，如下图所示，其目的就是把样本的中心拉回到坐标系原点上。</li>
<li><strong>归一化</strong>：幅度归一化到同样的范围，如下所示，即减少各维度数据取值范围的差异而带来的干扰，比如，我们有两个维度的特征 A 和 B，A 范围是 0 到 10，而 B 范围是 0 到 10000，如果直接使用这两个特征是有问题的，好的做法就是归一化，即 A 和 B 的数据都变为 0 到 1 的范围。</li>
<li><strong>PCA/白化</strong>：用 PCA 降维；白化是对数据各个特征轴上的幅度归一化</li>
</ul>
<p>去均值与归一化效果图：</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/去均值与归一化效果图.png" style="zoom:80%;"></p>
<p>去相关与白化效果图：</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/去相关与白化效果图.png" style="zoom:80%;"></p>
<h3 id="卷积计算层"><a href="#卷积计算层" class="headerlink" title="卷积计算层"></a>卷积计算层</h3><p>这一层就是卷积神经网络最重要的一个层次，也是“卷积神经网络”的名字来源。</p>
<p>在这个卷积层，有两个关键操作：</p>
<ul>
<li><strong>局部关联</strong>。每个神经元看做一个滤波器(filter)</li>
<li><strong>窗口(receptive field)滑动</strong>， filter 对局部数据计算</li>
</ul>
<p>先介绍卷积层遇到的几个名词：</p>
<ul>
<li><strong>深度/depth</strong>（解释见下图）</li>
<li><strong>步幅/stride</strong> （窗口一次滑动的长度）</li>
<li><strong>填充值/zero-padding</strong></li>
</ul>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积计算层.png" style="zoom:80%;"></p>
<p>现在，要改变每一层的行为，有两个主要参数是我们可以调整的。选择了过滤器的尺寸以后，我们还需要选择步幅（stride）和填充（padding）。</p>
<p>步幅控制着过滤器围绕输入内容进行卷积计算的方式。在第一部分我们举的例子中，过滤器通过每次移动一个单元的方式对输入内容进行卷积。过滤器移动的距离就是步幅。在那个例子中，步幅被默认设置为 1。步幅的设置通常要确保输出内容是一个整数而非分数。让我们看一个例子。想象一个 7 x 7 的输入图像，一个 3 x 3 过滤器（简单起见不考虑第三个维度），步幅为 1。这是一种惯常的情况。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积-步长1.png" alt="img"></p>
<p>如果步幅增加到 2，输出内容会怎么样。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积-步长2.png" alt="img"></p>
<p>所以，正如你能想到的，感受野移动了两个单元，输出内容同样也会减小。注意，如果试图把我们的步幅设置成 3，那我们就会难以调节间距并确保感受野与输入图像匹配。正常情况下，程序员如果想让接受域重叠得更少并且想要更小的空间维度（spatial dimensions）时，他们会增加步幅。</p>
<p><strong>填充值是什么呢？</strong></p>
<p>在此之前，想象一个场景：当你把 5 x 5 x 3 的过滤器用在 32 x 32 x 3 的输入上时，会发生什么？输出的大小会是 28 x 28 x 3。注意，这里空间维度减小了。如果我们继续用卷积层，尺寸减小的速度就会超过我们的期望。在网络的早期层中，我们想要尽可能多地保留原始输入内容的信息，这样我们就能提取出那些低层的特征。比如说我们想要应用同样的卷积层，但又想让输出量维持为 32 x 32 x 3 。为做到这点，我们可以对这个层应用大小为 2 的零填充（zero padding）。零填充在输入内容的边界周围补充零。如果我们用两个零填充，就会得到一个 36 x 36 x 3 的输入卷。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/填充值.png" style="zoom:80%;"></p>
<p>如果我们在输入内容的周围应用两次零填充，那么输入量就为 32×32×3。然后，当我们应用带有 3 个 5×5×3 的过滤器，以 1 的步幅进行处理时，我们也可以得到一个 32×32×3 的输出</p>
<p>如果你的步幅为 1，而且把零填充设置为</p>
<p>\begin{flalign}<br>        Zero~Padding = (K-1)/2<br>        \end{flalign}</p>
<p>K 是过滤器尺寸，那么输入和输出内容就总能保持一致的空间维度。</p>
<p>计算任意给定卷积层的输出的大小的公式是</p>
<p>\begin{flalign}<br>        O = (W-K+2P)/S + 1<br>        \end{flalign}</p>
<p>其中 O 是输出尺寸，K 是过滤器尺寸，P 是填充，S 是步幅。</p>
<h4 id="卷积的计算"><a href="#卷积的计算" class="headerlink" title="卷积的计算"></a>卷积的计算</h4><p>下面蓝色矩阵周围有一圈灰色的框，那些就是上面所说到的填充值</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积的计算.png" style="zoom:80%;"></p>
<p>这里的蓝色矩阵就是输入的图像，粉色矩阵就是卷积层的神经元，这里表示了有两个神经元（w0,w1）。绿色矩阵就是经过卷积运算后的输出矩阵，这里的步长设置为 2。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积的计算-2.png" style="zoom:80%;"></p>
<p>蓝色的矩阵(输入图像)对粉色的矩阵（filter）进行矩阵内积计算并将三个内积运算的结果与偏置值 b 相加（比如上面图的计算：2+（-2+1-2）+（1-2-2） + 1= 2 - 3 - 3 + 1 = -3），计算后的值就是绿框矩阵的一个元素。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积层-降维.png" style="zoom:80%;"></p>
<p>下面的动态图形象地展示了卷积层的计算过程：</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积层计算过程.gif" style="zoom: 80%"></p>
<h4 id="参数共享机制"><a href="#参数共享机制" class="headerlink" title="参数共享机制"></a>参数共享机制</h4><p>在卷积层中每个神经元连接数据窗的权重是固定的，每个神经元只关注一个特性。神经元就是图像处理中的滤波器，比如边缘检测专用的 Sobel 滤波器，即卷积层的每个滤波器都会有自己所关注一个图像特征，比如垂直边缘，水平边缘，颜色，纹理等等，这些所有神经元加起来就好比就是整张图像的特征提取器集合。</p>
<p>需要估算的权重个数减少: AlexNet 1 亿 =&gt; 3.5w</p>
<p>一组固定的权重和不同窗口内数据做内积: 卷积</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/卷积效果图.png" style="zoom:80%;"></p>
<h3 id="非线性层（或激活层）"><a href="#非线性层（或激活层）" class="headerlink" title="非线性层（或激活层）"></a>非线性层（或激活层）</h3><p>把卷积层输出结果做非线性映射。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/激活层.png" style="zoom:80%;"></p>
<p>CNN 采用的激活函数一般为 ReLU(The Rectified Linear Unit/修正线性单元)，它的特点是收敛快，求梯度简单，但较脆弱，图像如下。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/激活函数图像.png" style="zoom:80%;"></p>
<p><strong>激励层的实践经验：</strong></p>
<p>①不要用 sigmoid！不要用 sigmoid！不要用 sigmoid！</p>
<p>② 首先试 RELU，因为快，但要小心点</p>
<p>③ 如果 2 失效，请用 Leaky ReLU 或者 Maxout</p>
<p>④ 某些情况下 tanh 倒是有不错的结果，但是很少</p>
<p>参见 Geoffrey Hinton（即深度学习之父）的论文：Rectified Linear Units Improve Restricted Boltzmann Machines <strong>墙裂推荐此论文！</strong></p>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化层夹在连续的卷积层中间， 用于压缩数据和参数的量，减小过拟合。</p>
<p>简而言之，如<strong>果输入是图像的话，那么池化层的最主要作用就是压缩图像。</strong></p>
<p>池化层的具体作用：</p>
<ul>
<li><strong>特征不变性</strong>，也就是我们在图像处理中经常提到的特征的尺度不变性，池化操作就是图像的 resize，平时一张狗的图像被缩小了一倍我们还能认出这是一张狗的照片，这说明这张图像中仍保留着狗最重要的特征，我们一看就能判断图像中画的是一只狗，图像压缩时去掉的信息只是一些无关紧要的信息，而留下的信息则是具有尺度不变性的特征，是最能表达图像的特征。</li>
<li><strong>特征降维</strong>，我们知道一幅图像含有的信息是很大的，特征也很多，但是有些信息对于我们做图像任务时没有太多用途或者有重复，我们可以把这类冗余信息去除，把最重要的特征抽取出来，这也是池化操作的一大作用。</li>
<li>在一定程度上<strong>防止过拟合</strong>，更方便优化。</li>
</ul>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/池化层.png" style="zoom:80%;"></p>
<p>池化层用的方法有 Max pooling 和 average pooling，而实际用的较多的是 Max pooling。这里就说一下 Max pooling，其实思想非常简单。</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/池化层方法.png" style="zoom:80%;"></p>
<p>对于每个 2 <em> 2 的窗口选出最大的数作为输出矩阵的相应元素的值，比如输入矩阵第一个 2 </em> 2 窗口中最大的数是 6，那么输出矩阵的第一个元素就是 6，如此类推。</p>
<h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>两层之间所有神经元都有权重连接，通常全连接层在卷积神经网络尾部。也就是跟传统的神经网络神经元的连接方式是一样的：</p>
<p><img src="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%B9%8BCNN%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89CNN%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/全连接层.PNG" style="zoom:80%;"></p>
<p>一般 CNN 结构依次为</p>
<ul>
<li>INPUT</li>
<li>[[CONV -&gt; RELU]N -&gt; POOL?]M</li>
<li>[FC -&gt; RELU]*K</li>
<li>FC</li>
</ul>
<h1 id="卷积神经网络的几点说明"><a href="#卷积神经网络的几点说明" class="headerlink" title="卷积神经网络的几点说明"></a><strong>卷积神经网络的几点说明</strong></h1><h2 id="训练算法"><a href="#训练算法" class="headerlink" title="训练算法"></a>训练算法</h2><ul>
<li>同一般机器学习算法，先定义 Loss function，衡量和实际结果之间差距。</li>
<li>找到最小化损失函数的 W 和 b， CNN 中用的算法是 SGD（随机梯度下降）。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>共享卷积核，对高维数据处理无压力</li>
<li>无需手动选取特征，训练好权重，即得特征分类效果好</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>需要调参，需要大样本量，训练最好要 GPU</li>
<li>物理含义不明确（也就说，我们并不知道没个卷积层到底提取到的是什么特征，而且神经网络本身就是一种难以解释的“黑箱模型”）</li>
</ul>
<h2 id="典型-CNN"><a href="#典型-CNN" class="headerlink" title="典型 CNN"></a>典型 CNN</h2><ul>
<li>LeNet，这是最早用于数字识别的 CNN</li>
<li>AlexNet， 2012 ILSVRC 比赛远超第 2 名的 CNN，比</li>
<li>LeNet 更深，用多层小卷积层叠加替换单大卷积层。</li>
<li>ZF Net， 2013 ILSVRC 比赛冠军</li>
<li>GoogLeNet， 2014 ILSVRC 比赛冠军</li>
<li>VGGNet， 2014 ILSVRC 比赛中的模型，图像识别略差于 GoogLeNet，但是在很多图像转化学习问题(比如 object detection)上效果奇好</li>
</ul>
<h2 id="fine-tuning"><a href="#fine-tuning" class="headerlink" title="fine-tuning"></a>fine-tuning</h2><p><strong>何谓 fine-tuning？</strong></p>
<p>fine-tuning 就是使用已用于其他目标、预训练好模型的权重或者部分权重，作为初始值开始训练。</p>
<p>那为什么我们不用随机选取选几个数作为权重初始值？原因很简单，第一，自己从头训练卷积神经网络容易出现问题；第二，fine-tuning 能很快收敛到一个较理想的状态，省时又省心。</p>
<p><strong>那 fine-tuning 的具体做法是？</strong></p>
<ul>
<li>复用相同层的权重，新定义层取随机权重初始值</li>
<li>调大新定义层的的学习率，调小复用层学习率</li>
</ul>
<h2 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h2><p><strong>Caffe</strong></p>
<ul>
<li>源于 Berkeley 的主流 CV 工具包，支持 C++,python,matlab</li>
<li>Model Zoo 中有大量预训练好的模型供使用</li>
</ul>
<p><strong>PyTorch</strong></p>
<ul>
<li>Facebook 用的卷积神经网络工具包</li>
<li>通过时域卷积的本地接口，使用非常直观</li>
<li>定义新网络层简单</li>
</ul>
<p><strong>TensorFlow</strong></p>
<ul>
<li>Google 的深度学习框架</li>
<li>TensorBoard 可视化很方便</li>
<li>数据和模型并行化好，速度快</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。</p>
<p>CNN 一个非常重要的特点就是头重脚轻（越往输入权值越小，越往输出权值越多），呈现出一个倒三角的形态，这就很好地避免了 BP 神经网络中反向传播的时候梯度损失得太快。</p>
<p>卷积神经网络 CNN 主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于 CNN 的特征检测层通过训练数据进行学习，所以在使用 CNN 时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">深度学习之三大算法：CNN、RNN和GAN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-25 22:06:58 / 修改时间：22:14:24" itemprop="dateCreated datePublished" datetime="2023-04-25T22:06:58+08:00">2023-04-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
        </span>
    </span>

  
    <span id="/2023/04/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%89%E5%A4%A7%E7%AE%97%E6%B3%95/" class="post-meta-item leancloud_visitors" data-flag-title="深度学习之三大算法：CNN、RNN和GAN" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>以算法区分深度学习应用，算法类别可分成三大类：</p>
<ul>
<li>常用于影像数据进行分析处理的<strong>卷积神经网络(简称CNN)</strong></li>
<li>文本分析或自然语言处理的<strong>递归神经网络(简称RNN)</strong></li>
<li>常用于数据生成或非监督式学习应用的<strong>生成对抗网络(简称GAN)</strong></li>
</ul>
<h1 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a><strong>卷积神经网络CNN</strong></h1><p>因为应用种类多样，本篇会以算法类别细分，CNN主要应用可分为图像分类(image classification)、目标检测(object detection)及语义分割(semantic segmentation)。</p>
<h2 id="1、图像分类-Classification"><a href="#1、图像分类-Classification" class="headerlink" title="1、图像分类(Classification)"></a><strong>1、图像分类(Classification)</strong></h2><p>将图像进行类别筛选，通过深度学习方法识别图片属于哪种分类类别，其主要重点在于一张图像只包含一种分类类别，即使该影像内容可能有多个目标，所以单纯图像分类的应用并不普遍。不过由于单一目标识别对深度学习算法来说是正确率最高的，所以实际上很多应用会先通过目标检测方法找到该目标，再缩小撷取影像范围进行图像分类。所以只要是目标检测可应用的范围，通常也会使用图像分类方法。</p>
<p>图像分类也是众多用来测试算法基准的方法之一，常使用由ImageNet举办的大规模视觉识别挑战赛(ILSVRC)中提供的公开图像数据进行算法测试。图像分类属于CNN的基础，其相关算法也是最易于理解，故初学者应该都先以图像分类做为跨入深度学习分析的起步。使用图像分类进行识别，通常输入为一张图像，而输出为一个文字类别。</p>
<h2 id="2、目标检测-Object-Detection"><a href="#2、目标检测-Object-Detection" class="headerlink" title="2、目标检测 (Object Detection)"></a><strong>2、目标检测 (Object Detection)</strong></h2><p>一张图像内可有一或多个目标物，目标物也可以是属于不同类别。算法主要能达到两种目的：找到目标坐标及识别目标类别。简单来说，就是除了需要知道目标是什么，还需要知道它在哪个位置。</p>
<p>目标检测应用非常普遍，包含文章开头提到的人脸识别相关技术结合应用，或是制造业方面的瑕疵检测，甚至医院用于X光、超音波进行特定身体部位的病况检测等。目标识别的基础可想象为在图像分类上增加标示位置的功能，故学习上也不离图像分类的基础。不过目标检测所标示的坐标通常为矩形或方形，仅知道目标所在位置，并无法针对目标的边缘进行描绘，所以常用见的应用通常会以「知道目标位置即可」作为目标。</p>
<p>最常见的算法为YOLO及R-CNN。其中YOLO因算法特性具有较快的识别速度，目前已来到v3版本。R-CNN针对目标位置搜寻及辨识算法和YOLO稍有不同，虽然速度稍较YOLO慢，但正确率稍高于YOLO。使用目标检测进行识别，通常输入为一张图像，而输出为一个或数个文字类别和一组或多组坐标。</p>
<h2 id="3、语义分割-Semantic-Segmentation"><a href="#3、语义分割-Semantic-Segmentation" class="headerlink" title="3、语义分割 (Semantic Segmentation)"></a><strong>3、语义分割 (Semantic Segmentation)</strong></h2><p>算法会针对一张图像中的每个像素进行识别，也就是说不同于目标检测，语义分割可以正确区别各目标的边界像素，简单来说，语义分割就是像素级别的图像分类，针对每个像素进行分类。当然这类应用的模型就会需要较强大的GPU和花较多时间进行训练。</p>
<p>常见应用类似目标检测，但会使用在对于图像识别有较高精细度，如需要描绘出目标边界的应用。例如制造业上的瑕疵检测，针对不规则形状的大小瑕疵，都可以正确描绘。医学上常用于分辨病理切片上的病变细胞，或是透过MRI、X光或超音波描绘出病变的区块及类别。算法如U-Net或是Mask R-CNN都是常见的实作方法。使用语义分割进行识别，通常输入为一张图像，而输出也为一张等大小的图像，但图像中会以不同色调描绘不同类别的像素。</p>
<h1 id="递归神经网络RNN"><a href="#递归神经网络RNN" class="headerlink" title="递归神经网络RNN"></a><strong>递归神经网络RNN</strong></h1><p>有别于CNN，RNN的特色在于可处理图像或数值数据，并且由于网络本身具有记忆能力，可学习具有前后相关的数据类型。例如进行语言翻译或文本翻译，一个句子中的前后词汇通常会有一定的关系，但CNN网络无法学习到这层关系，而RNN因具有内存，所以性能会比较好。因为可以通过RNN进行文字理解，其他应用如输入一张图像，但是输出为一段关于图像叙述的句子。</p>
<p>RNN虽然解决了CNN无法处理的问题，但其本身仍然有些缺点，所以现在很多RNN的变形网络，其中最常被使用的网络之一为长短记忆网络(Long Short-Term Network，简称LSTM)。这类网络的输入数据不限于是图像或文字，解决的问题也不限于翻译或文字理解。数值相关数据也同样可以使用LSTM进行分析，例如工厂机器预测性维修应用，可透过LSTM分析机台震动讯号，预测机器是否故障。在医学方面，LSTM可协助解读数以千计的文献，并找出特定癌症的相关信息，例如肿瘤部位、肿瘤大小、期数，甚至治疗方针或存活率等等，透过文字理解进行解析。也可结合图像识别提供病灶关键词，以协助医生撰写病理报告。</p>
<h1 id="生成对抗网络GAN"><a href="#生成对抗网络GAN" class="headerlink" title="生成对抗网络GAN"></a><strong>生成对抗网络GAN</strong></h1><p>除了深度学习外，有一种新兴的网络称为强化学习(Reinforcement Learning)，其中一种很具有特色的网络为生成式对抗网络(GAN)。</p>
<p>GAN的应用相关论文成长幅度相当大</p>
<p>深度学习领域最需要的是数据，但往往不是所有应用都可以收集到大量数据，并且数据也需要人工进行标注，这是非常消耗时间及人力成本。图像数据可以通过旋转、裁切或改变明暗等方式增加数据量，但如果数据还是不够呢？目前有相当多领域透过GAN方法生成非常近似原始数据的数据，例如3D-GAN就是可以生成高质量3D对象。当然，比较有趣的应用例如人脸置换或表情置换。</p>
<p>另外，SRGAN (Super Resolution GAN)可用于提高原始图像的分辨率，将作为低分辨率影像输入进GAN模型，并生成较高画质的影像(如下图)。这样的技术可整合至专业绘图软件中，协助设计师更有效率完成设计工作。</p>
<p>NVIDIA也有提供一些基于GAN的平台的应用，包含透过GauGAN网络，仅需绘制简单的线条，即可完成漂亮的画作，并且还能随意修改场景的风格。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数据结构-第十章查找</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-23 22:50:37" itemprop="dateCreated datePublished" datetime="2023-04-23T22:50:37+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 00:02:16" itemprop="dateModified" datetime="2023-04-26T00:02:16+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%9F%A5%E6%89%BE/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第十章查找" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第十章查找"><a href="#第十章查找" class="headerlink" title="第十章查找"></a>第十章查找</h1><h2 id="第一节查找的概念"><a href="#第一节查找的概念" class="headerlink" title="第一节查找的概念"></a>第一节查找的概念</h2><p>在数据集合中寻找满足某种条件的数据元素的过程</p>
<h2 id="第二节静态查找"><a href="#第二节静态查找" class="headerlink" title="第二节静态查找"></a>第二节静态查找</h2><h3 id="1-顺序（线性）查找"><a href="#1-顺序（线性）查找" class="headerlink" title="1.顺序（线性）查找"></a>1.顺序（线性）查找</h3><h4 id="（1）一般线性表的查找"><a href="#（1）一般线性表的查找" class="headerlink" title="（1）一般线性表的查找"></a>（1）一般线性表的查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;					<span class="comment">//查找表的数据结构</span></span><br><span class="line">    ElemType *elem;				<span class="comment">//元素存储空间基址，建表时按实际长度分配，0号单元留空</span></span><br><span class="line">    <span class="type">int</span> TableLen;				<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;			<span class="comment">//哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(i = ST.TableLen;ST.elem[i]!=key,--i);	<span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;					<span class="comment">//若表中不存在关键字为key的元素，将查找到i=0时退出for循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需进行n-i+1次关键词的比较。</p>
<p>\begin{flalign}<br>&amp;1.查找成功时:\\<br>&amp;顺序查找的平均长度为：ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)\\<br>&amp;当每个元素的查找概率相等，即P_i=1/n时，有：ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)=(n+1)/2\\<br>&amp;2.查找失败时：\\<br>&amp;与表中各关键词的比较次数时n+1次，从而顺序查找不成功的平均查找长度为：ASL_{不成功} = n+1<br>\end{flalign}</p>
<h4 id="（2）有序表的查找"><a href="#（2）有序表的查找" class="headerlink" title="（2）有序表的查找"></a>（2）有序表的查找</h4><p>\begin{flalign}<br>&amp;1.查找成功时:\\<br>&amp;顺序查找的平均长度为：ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)\\<br>&amp;当每个元素的查找概率相等，即P_i=1/n时，有：ASL_{成功} = \sum_{i=1}^nP_i(n-i+1)=(n+1)/2\\<br>&amp;2.查找失败时：\\<br>&amp;查找不成功的平均查找长度为：ASL_{不成功} = \sum_{j=1}^nq_i(l_j-1)=(1+2…+n+n)/(n+1)=n/2+n/(n+1)<br>\end{flalign}</p>
<h3 id="2-二分（折半）查找"><a href="#2-二分（折半）查找" class="headerlink" title="2.二分（折半）查找"></a>2.二分（折半）查找</h3><p>时间复杂度：O(logn)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>,high = L.TableLen<span class="number">-1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        min = (low+high)/<span class="number">2</span>;							<span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] = key)	<span class="keyword">return</span> min;			<span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]&gt;key)	high = mid<span class="number">-1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span>	low = mid+<span class="number">1</span>;						<span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;										<span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>\begin{flalign}<br>&amp;ASL_{成功} = 1/n\sum_{i=1}^nl_i=1/n(1<em>1+2</em>2+…+h<em>2^{h-1})=(n+1)/n</em>log_2(n+1)≈log_2(n+1)-1\\<br>\end{flalign}</p>
<h3 id="3-索引（分块）查找"><a href="#3-索引（分块）查找" class="headerlink" title="3.索引（分块）查找"></a>3.索引（分块）查找</h3><p>基本思想：将查找表氛围若干子块。块内元素可以无序，但块之间时有序的，即第一个块中的最大关键字小于第二块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</p>
<script type="math/tex; mode=display">
\begin{flalign}
&1.分块查找的平均查找长度为索引查找和块内查找的平均长度之和，设索引查找和块内查找的平均查找长度分别为L_l和L_s\\
&~~~则分块查找的平均查找长度为：ASL = L_l+L_s\\
&2.将长度为n的查找表均匀的分成b块，每块有s各记录，在等概率情况下，若块内和索引表中均采用顺序查找\\
&~~~则平均查找长度为：ASL = L_l+L_s = (b+1)/2+(s+1)/2 = (s^2+2s+n)/(2s)\\
&3.若s = \sqrt n，则平均查找长度取最小值\sqrt n+1；\\
&4.若对索引表采用折半查找时，\\
&~~~则平均查找长度为ASL= L_l+L_s = \lceil log_2(b+1)\rceil+(s+1)/2
\end{flalign}</script><h2 id="第三节动态查找"><a href="#第三节动态查找" class="headerlink" title="第三节动态查找"></a>第三节动态查找</h2><h3 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h3><p>二叉排序树（二叉查找树）或者是一棵空树，或者时具有下列特性的二叉树：</p>
<p>1）若左子树非空，则左子树上所有结点的值均小于根结点的值；</p>
<p>2）若右子树非空，则右子树上所有结点的值均大于根结点的值；</p>
<p>3）左、右子数也分别是一棵二叉排序树。</p>
<h4 id="（1）查找"><a href="#（1）查找" class="headerlink" title="（1）查找"></a>（1）查找</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BiTree T,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T&amp;&amp;key!=T-&gt;data)&#123;				<span class="comment">//若树空或等于根结点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;data)	T = T-&gt;lchild;	<span class="comment">//小于，则在左子树上查找</span></span><br><span class="line">        <span class="keyword">else</span>	T = T-&gt;rchild;			<span class="comment">//大于，则在右子树上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）插入"><a href="#（2）插入" class="headerlink" title="（2）插入"></a>（2）插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BST_Insert</span><span class="params">(BiTree &amp;T,KetType k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;									<span class="comment">//原树为空，新插入的记录为新结点</span></span><br><span class="line">        T = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;data = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;							<span class="comment">//返回1，表示插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;data)	<span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-data)		<span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild,k);		<span class="comment">//插入到T的左子树</span></span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild,k);		<span class="comment">//插入到T的右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）构造"><a href="#（3）构造" class="headerlink" title="（3）构造"></a>（3）构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Creat_BST</span><span class="params">(BiTree &amp;T,KetType str[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;					<span class="comment">//初始时T为空树</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;				<span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T,str[i]);	</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）删除"><a href="#（4）删除" class="headerlink" title="（4）删除"></a>（4）删除</h4><p>①若被删除结点z时叶结点，则直接删除，不会破坏二叉排序树的性质；</p>
<p>②若结点z只有一棵左子树或右子树，则让z的子数称为z父节点的子数，代替z的位置；</p>
<p>③若结点z有左、右两棵子数，则令z的直接后继（或直接前驱）替代z，然后二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一种或第二种情况。</p>
<pre class="mermaid">graph TB;
A((53))
B((17))
C((78))
D((09))
E((45))
F((65))
G((94))
H((81))
I((88))
J((23))
A-->B
A-->C
B-->D
B-->E
C-->F
C-->G
E-->J
G-->H
H-->I</pre>

<p>删除78结点后</p>
<pre class="mermaid">graph TB;
A((53))
B((17))
D((09))
E((45))
F((65))
G((94))
H((81))
I((88))
J((23))
A-->B
A-->H
B-->D
B-->E
E-->J
H-->F
H-->G
G-->I</pre>

<p>\begin{flalign}<br>平衡二叉树的递推公式：n_0=0,n_1=1,n_2=2,n_h=1+n_{h-1}+n_{h-2}<br>\end{flalign}</p>
<h2 id="第四节哈希查找（散列表）"><a href="#第四节哈希查找（散列表）" class="headerlink" title="第四节哈希查找（散列表）"></a>第四节哈希查找（散列表）</h2><h3 id="1-哈希查找的概念"><a href="#1-哈希查找的概念" class="headerlink" title="1.哈希查找的概念"></a>1.哈希查找的概念</h3><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr（这里的地址可以实数组下标、索引或内存地址等）</p>
<p>散列表：根据关键字而直接进行访问的数据结构。即<em>散列表建立了关键字和存储地址之间的一种直接映射关系</em>。</p>
<h3 id="2-哈希函数"><a href="#2-哈希函数" class="headerlink" title="2.哈希函数"></a>2.哈希函数</h3><h4 id="（1）直接定址法"><a href="#（1）直接定址法" class="headerlink" title="（1）直接定址法"></a>（1）直接定址法</h4><p>\begin{flalign}<br>H(key)=key或H(key)=a×key+b<br>\end{flalign}</p>
<h4 id="（2）除留余数法"><a href="#（2）除留余数法" class="headerlink" title="（2）除留余数法"></a>（2）除留余数法</h4><p>假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，则散列函数如下：</p>
<p>\begin{flalign}<br>H(key)=key\%p<br>\end{flalign}</p>
<h4 id="（3）数字分析法"><a href="#（3）数字分析法" class="headerlink" title="（3）数字分析法"></a>（3）数字分析法</h4><h4 id="（4）平方取中法"><a href="#（4）平方取中法" class="headerlink" title="（4）平方取中法"></a>（4）平方取中法</h4><p>取关键字的平方值的中间几位作为散列地址。适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</p>
<h3 id="3-哈希冲突的解决方法"><a href="#3-哈希冲突的解决方法" class="headerlink" title="3.哈希冲突的解决方法"></a>3.哈希冲突的解决方法</h3><h4 id="（1）开放地址法"><a href="#（1）开放地址法" class="headerlink" title="（1）开放地址法"></a>（1）开放地址法</h4><p>\begin{flalign}<br>H_i = (H(key)+d_i)\%m\\<br>H(key)为散列函数：i = 0,1,2,..,k(k ≤ m-1)；m表示散列表表长；d_i为增量序列<br>\end{flalign}</p>
<h5 id="—a-线性探测法"><a href="#—a-线性探测法" class="headerlink" title="—a.线性探测法"></a>—a.线性探测法</h5><p>特点：冲突发生时，顺序查看表中下一个单元（探测到表尾地址m-1时，下一个探测地址时表首地址0），知道招初一个空闲单元（当表为填满时一定要找到一个空闲单元）或查遍全表。</p>
<p>缺点：容易造成大量元素在相邻的散列地址上“聚集”（或堆积）起来，大大降低查找效率。</p>
<h5 id="—b-平方探测法"><a href="#—b-平方探测法" class="headerlink" title="—b.平方探测法"></a>—b.平方探测法</h5><p>特点：当d~i~ = 0²，1²，-1²，2²，-2²，…，k²，-k²时，称为平方探测法，其中k ≤ m/2，散列表长度m必须是一个可以表示成4k+3的素数，又称二次探测法。</p>
<p>优点：可以避免出现“堆积”问题。</p>
<p>缺点：不能探测散列表上的所有单元，但至少可以探测到一半单元。</p>
<h5 id="—c-双散列法"><a href="#—c-双散列法" class="headerlink" title="—c.双散列法"></a>—c.双散列法</h5><p>​        当d~i~=Hash~2~(key)时，称为双散列法。当通过第一个散列函数H(key)得到的地址发生冲突时，利用第二个散列函数Hash~2~(key)计算该关键字的地址增量。具体散列函数形式如下：</p>
<p>\begin{flalign}<br>H_i=(H(key)+i×Hash_2(key))\%m<br>\end{flalign}</p>
<p>初始探测位置H~0~=H(key)%m。i是冲突的次数，初始为0。最多经过m-1次探测就会遍历表中所有位置，回到H~0~位置。</p>
<h5 id="—d-伪随机序列法"><a href="#—d-伪随机序列法" class="headerlink" title="—d.伪随机序列法"></a>—d.伪随机序列法</h5><p>d~i~ = 伪随机序列时，称为伪随机序列法。</p>
<h4 id="（2）拉链法（链接法）"><a href="#（2）拉链法（链接法）" class="headerlink" title="（2）拉链法（链接法）"></a>（2）拉链法（链接法）</h4><p>同线性探测法，但改为链表形式。</p>
<h3 id="4-散列查找及性能分析"><a href="#4-散列查找及性能分析" class="headerlink" title="4.散列查找及性能分析"></a>4.散列查找及性能分析</h3><p>散列表的查找效率取决三个因素：散列函数、处理冲突的方法和装填因子。</p>
<p>\begin{flalign}<br>\alpha = 表中记录数n/散列表长度m<br>\end{flalign}</p>
<p>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观地看，α越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">数据结构-第九章排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-23 22:49:09" itemprop="dateCreated datePublished" datetime="2023-04-23T22:49:09+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 00:12:09" itemprop="dateModified" datetime="2023-04-26T00:12:09+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8E%92%E5%BA%8F/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第九章排序" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第九章排序"><a href="#第九章排序" class="headerlink" title="第九章排序"></a>第九章排序</h1><h2 id="1-排序的概念"><a href="#1-排序的概念" class="headerlink" title="1.排序的概念"></a>1.排序的概念</h2><p>\begin{flalign}<br>&amp;排序：按照一定的关键字，将一个序列排列成想要得到的一个新的序列。\\<br>&amp;稳定性：若待排序表中有两个元素 R_i 和 R_j，其对应的关键字相同即 key_i = key_j，且在排序前 R_i 在 R_j 的前面，\\<br>&amp;~若使用某一排序算法排序后，R_i 仍然在 R_j 的前⾯，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\\<br>&amp;内部排序和外部排序：整个排序过程完全在内存中进行，叫做内部排序。数据量较大需要借助外部存储设备才能完成，叫做外部排序。<br>\end{flalign}</p>
<h2 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2.插入排序"></a>2.插入排序</h2><h3 id="（1）直接插入排序"><a href="#（1）直接插入排序" class="headerlink" title="（1）直接插入排序"></a>（1）直接插入排序</h3><p><em>①</em>  思想：最基本的插入排序，将第<em>i</em>个插入到前<em>i-1</em>个中的适当位置。</p>
<p><em>②</em>  时间复杂度：<em>T(n) = O(n</em>²<em>)</em>。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;	<span class="comment">//将各元素插入已排好序的序列中,位置0的是有序的，所以从1开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j; i &lt; n; ++i) &#123;    </span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i<span class="number">-1</span>]) &#123;          <span class="comment">//若A[i]小于前驱元素</span></span><br><span class="line">            <span class="type">int</span> temp = A[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; --j) &#123;   <span class="comment">//检查所有前面已排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];    <span class="comment">//所有大于A[i]的元素都向后挪位</span></span><br><span class="line">            &#125;</span><br><span class="line">            A[j+<span class="number">1</span>] = temp;        <span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）折半插入排序"><a href="#（2）折半插入排序" class="headerlink" title="（2）折半插入排序"></a>（2）折半插入排序</h3><p><em>①</em>  思想：因为是已经确定了前部分是有序序列，所以在查找插入位置的时候可以用折半查找的方法进行查找，提高效率。</p>
<p><em>②</em>  时间复杂度：比较时的时间减为O(nlogn)，但是移动元素的时间耗费未变，所以总是得时间复杂度还是O(n²)。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort2</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;		<span class="comment">//依次将A[1]~A[i-1]插入到前面已排序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = A[i];</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;   <span class="comment">//折半查找</span></span><br><span class="line">            <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; temp) </span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= low; --j) &#123;		<span class="comment">//将[low, i-1]内的元素全部右移，空出插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = temp;  <span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）希尔排序"><a href="#（3）希尔排序" class="headerlink" title="（3）希尔排序"></a>（3）希尔排序</h3><p><em>①</em>  思想：又称缩小增量排序法。把待排序序列分成若干较小的子序列，然后逐个使用直接插入排序法排序，最后再对一个较为有序的序列进行一次排序，主要是为了减少移动的次数，提高效率。原理应该就是从无序到渐渐有序，要比直接从无序到有序移动的次数会少一些。</p>
<p><em>②</em>  时间复杂度：时间复杂度与增量序列的选择有关，最坏时间复杂度为O(n²)，当n在某个范围内时，可达O(n^1.3)。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：不稳定排序。仅适用于顺序表，不适用于链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = n/<span class="number">2</span>; d &gt;= <span class="number">1</span>; d /= <span class="number">2</span>) &#123;   <span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d, j; i &lt; n; i += d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i-d]) &#123;  <span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">                <span class="type">int</span> temp = A[i];    <span class="comment">//暂存元素</span></span><br><span class="line">                <span class="keyword">for</span> (j = i-d; j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; temp; j -= d) &#123;</span><br><span class="line">                    A[j+d] = A[j];    <span class="comment">//元素后移，查找插入位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j+d] = temp;        <span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3.选择排序"></a>3.选择排序</h2><h3 id="（1）直接选择排序"><a href="#（1）直接选择排序" class="headerlink" title="（1）直接选择排序"></a>（1）直接选择排序</h3><p><em>①</em>  思想：首先在所有<strong>记录中选出关键字值最小的记录</strong>，把它与第一个记录进行位置交换，然后在其余的记录中再选出关键字值次小的记录与第二个记录进行位置交换，依此类推，直到所有记录排好序。</p>
<p><em>②</em>  时间复杂度：最好最坏平均时间复杂度为O(n²)。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：不稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp,flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag = i;						<span class="comment">//flag记录此刻需要确定最小值的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j &lt; n;j++)&#123;			<span class="comment">//在i+1的位置开始在后寻找最小关键字</span></span><br><span class="line">            <span class="keyword">if</span>(A[flag] &gt; A[j])</span><br><span class="line">                flag = j;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = A[flag];	A[flag] = A[i];	A[i] = temp;		<span class="comment">//将flag的数和后面的最小关键字交换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）堆排序"><a href="#（2）堆排序" class="headerlink" title="（2）堆排序"></a>（2）堆排序</h3><p><em>①</em>  思想<br>        作为选择排序的改进版，堆排序可以把每一趟元素的比较结果保存下来，以便我们在选择最小/大元素时对已经比较过的元素做出相应的调整。<br>        堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，每个节点都大（小）于它的两个子节点，每个节点都大于等于它的两个子节点时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，就称为小顶堆。</p>
<p><em>②</em>  时间复杂度：最好最坏平均时间复杂度为O(nlogn)。</p>
<p>​    调整时间和树的高度有关，为O(h)，在建立含n个元素的堆时，关键字的比较总次数不超过4*n，时间复杂度为O(n)</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：不稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i++)				<span class="comment">//从i = [n/2]~1，反复调整堆</span></span><br><span class="line">		<span class="built_in">HeapAdjust</span>(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(ElemType A[],<span class="type">int</span> k,<span class="type">int</span> len)</span></span>&#123;	<span class="comment">//函数HeapAdjust将元素k为根的子树进行调整</span></span><br><span class="line">    A[<span class="number">0</span>] = A[k];						<span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>*k;i &lt;= len;i++)&#123;			<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])		</span><br><span class="line">            i++;						<span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])	<span class="keyword">break</span>;			<span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];				<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k = i;						<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];						<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序算法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(ElemType A[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(A,len);				<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len;i&gt;<span class="number">1</span>;i++)&#123;			<span class="comment">//n-1趟的交换和建堆过程</span></span><br><span class="line">        <span class="built_in">Swap</span>(A[i],A[<span class="number">1</span>]);				<span class="comment">//输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(A,<span class="number">1</span>,i<span class="number">-1</span>);			<span class="comment">//调整，把剩余的i-1个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-交换排序"><a href="#4-交换排序" class="headerlink" title="4.交换排序"></a>4.交换排序</h2><h3 id="（1）冒泡排序"><a href="#（1）冒泡排序" class="headerlink" title="（1）冒泡排序"></a>（1）冒泡排序</h3><p><em>①</em>  思想：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。以升序冒泡为例：每趟排序过程中通过两两比较相邻元素，将小的数字放到前面，大的数字放到后面。</p>
<p><em>②</em>  时间复杂度：最好O(n)，最坏平均时间复杂度为O(n²)。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(1)</em>。</p>
<p><em>④</em>  稳定性：稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;				<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(j = n<span class="number">-1</span>;j &gt; i;j--)		<span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;		<span class="comment">//若为逆序</span></span><br><span class="line">                <span class="built_in">swap</span>(A[j<span class="number">-1</span>],A[j]);	<span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;					<span class="comment">//本趟遍历后没有发生变换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）快速排序"><a href="#（2）快速排序" class="headerlink" title="（2）快速排序"></a>（2）快速排序</h3><p><strong>当每次枢纽都把表等分为长度相近的两个子表时，速度是最快的</strong></p>
<p><em>①</em>  思想：快速排序时所有内部排序算法中平均性能最优的排序算法<br>        在待排序的元素任取一个元素作为基准(通常选第一个元素，但最好的选择方法是从待排序元素中随机选取一个作为基准)，称为基准元素；<br>        将待排序的元素进行分区，比基准元素大的元素放在它的右边，比其小的放在它的左边；<br>        对左右两个分区重复以上步骤直到所有元素都是有序的。</p>
<p><em>②</em>  时间复杂度：最好O(nlogn)，最坏时间复杂度为O(n²)。</p>
<p><em>③</em>  空间复杂度：<em>最好平均情况O(logn)，最坏情况O(n)</em>。</p>
<p><em>④</em>  稳定性：不稳定排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;								<span class="comment">//递归跳出条件</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">Partitio</span>(A,low,high);			<span class="comment">//划分，将A[low...high]划分为满足上述条件要求的两个字表</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A,low,pos<span class="number">-1</span>);					<span class="comment">//依次对两个子表进行递归排序</span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A,pos+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Partition</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;		<span class="comment">//一趟划分</span></span><br><span class="line">    ElemType pivot = A[low];						<span class="comment">//设当前表中第一个元素为枢纽，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;								<span class="comment">//循环跳出条件</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot)	--high;</span><br><span class="line">        A[low] = A[high];							<span class="comment">//将比枢纽小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot)	++low;</span><br><span class="line">        A[high] = A[low];							<span class="comment">//将比枢纽大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;								<span class="comment">//枢纽存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;									<span class="comment">//返回存放枢纽的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5.归并排序"></a>5.归并排序</h2><p><em>①</em>  思想：将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。</p>
<p><em>②</em>  时间复杂度：归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是<strong>O(nlogn)</strong>。</p>
<p><em>③</em>  空间复杂度：<em>S(n) = O(n)</em>。</p>
<p><em>④</em>  稳定性：稳定排序。</p>
<p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%8E%92%E5%BA%8F/归并排序.png" style="zoom:80%;"></p>
<h2 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="6.基数排序"></a>6.基数排序</h2><p><strong>基数排序的效率和初始序列是否有序没有关联。</strong></p>
<p><em>①</em>  思想：<strong>不需要比较关键字的大小</strong>。根据关键字中各位的值，通过对排序的N个元素进行若干趟“分配”与“收集”来实现排序的。</p>
<p><em>②</em>  时间复杂度：假设在基数排序中，r为基数，d为位数。则基数排序的时间复杂度为<strong>O(d(n+r))</strong>。</p>
<p><em>③</em>  空间复杂度：对于任何位数上的基数进行“装桶”操作时，都需要<strong>n+r</strong>个临时空间。</p>
<p><em>④</em>  稳定性：稳定排序。</p>
<h2 id="7-排序算法总结"><a href="#7-排序算法总结" class="headerlink" title="7.排序算法总结"></a>7.排序算法总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">排序类别</th>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">折半插入排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"></td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center"></td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center">直接选择排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">堆排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">交换排序</td>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">快速排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n²)</td>
<td style="text-align:center">O(logn)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">归并排序</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">基数排序</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O(d(n+r))</td>
<td style="text-align:center">O(n+r)</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/" class="post-title-link" itemprop="url">数据结构-第八章图</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-23 22:48:23" itemprop="dateCreated datePublished" datetime="2023-04-23T22:48:23+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 00:10:56" itemprop="dateModified" datetime="2023-04-26T00:10:56+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第八章图" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第八章图"><a href="#第八章图" class="headerlink" title="第八章图"></a>第八章图</h1><h2 id="第一节图的概念和存储结构"><a href="#第一节图的概念和存储结构" class="headerlink" title="第一节图的概念和存储结构"></a>第一节图的概念和存储结构</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>线性表可以为空，树可以为空，但是图不能为空。图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空，此时图中只有顶点而没有边。</p>
<p>（1）有向图</p>
<script type="math/tex; mode=display">
G_1 = (V_1,E_1)\\
V_1 = \{1,2,3\}\\</script><script type="math/tex; mode=display">
E_1 = \{<1,2>,<2,1>,<2,3>\}</script><pre class="mermaid">graph LR;
A((1))
B((2))
C((3))
A-->B
B-->A
B-->C</pre>

<p>（2）无向图</p>
<script type="math/tex; mode=display">
G_1 = (V_1,E_1)\\
V_1 = \{1,2,3,4\}\\</script><script type="math/tex; mode=display">
E_1 = \{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}</script><p>（3）简单图、多重图</p>
<ul>
<li>简单图：①不存在重复边；②不存在顶点到自身的边。</li>
<li>多重图：图G中某两个顶点之间的边数大于1条，有允许顶点通过一条边和自身关联。</li>
</ul>
<p>（4）完全图（简单完全图）</p>
<script type="math/tex; mode=display">
\begin{flalign}
&无向完全图|E|取值范围 = [~~0,n(n-1)/2~~]\\
&有向完全图|E|取值范围 = [~~0,n(n-1)~~~~~~]
\end{flalign}</script><p>（5）子图：G = (V，E)和G<code>= (V</code>，E<code>)，若V</code>是V的子集，且E`是E的子集</p>
<p>（6）连通、连通图和连通分量（无向图）</p>
<ul>
<li>连通：无向图，顶点v和顶点w有路径存在，则称v和w是连通的</li>
<li>连通图：无向图图G任意两个顶点都是连通的，称连通图，否则为非连通图</li>
<li>连通分量：无向图的极大连通子图</li>
</ul>
<p>（7）强连通图、强连通分量（有向图）</p>
<ul>
<li>强连通：有向图，有一对顶点v和w，从v到w和w到v之间都有路径，则称两个顶点是强连通的</li>
<li>强连通图：任意一对顶点都是强连通的</li>
<li>强连通分量：有向图中的极大强连通分量</li>
</ul>
<p>（8）生成树、生成森林</p>
<p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若顶点数为n，则生成树含有n-1条边</p>
<p>（9）顶点的度、入度和出度</p>
<script type="math/tex; mode=display">
\begin{flalign}
&n个顶点e条边的无向图:\sum_{i=1}^nTD(v_i) = 2e\\
&n个顶点e条边的有向图：\sum_{i=1}^nID(v_i) = \sum_{i=1}^nOD(v_i) = e
\end{flalign}</script><p>（10）路径、路径长度、回路</p>
<p>若有一个图有n个顶点，并且有大于n-1条边，则该图一定有环</p>
<p>（11）简单路径、简单贿赂</p>
<ul>
<li>简单路径：顶点不重复出现的路径</li>
<li>简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路</li>
</ul>
<h3 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2.存储结构"></a>2.存储结构</h3><h4 id="（1）邻接矩阵法"><a href="#（1）邻接矩阵法" class="headerlink" title="（1）邻接矩阵法"></a>（1）邻接矩阵法</h4><p>空间复杂度O(n^2)</p>
<p>无权图</p>
<script type="math/tex; mode=display">
A[i][j] = 
\begin{cases}
1,~~~~~~~若(v_i,v_j)或<v_i.v_j>是E(G)中的边\\\\
0,~~~~~~~若(v_i,v_j)或<v_i.v_j>不是E(G)中的边\\
\end{cases}</script><p>​    举例如下：</p>
<pre class="mermaid">graph LR;
A((1))
B((2))
C((3))
D((4))
A-->B
A-->C
C-->D
D-->A</pre>

<script type="math/tex; mode=display">
A_1=\left[
\matrix{
 0 & 1 & 1 & 0\\
 0 & 0 & 0 & 0\\
 0 & 0 & 0 & 1\\
 1 & 0 & 0 & 0\\
}
\right]</script><p>有权图</p>
<script type="math/tex; mode=display">
A[i][j] = 
\begin{cases}
w_{ij},~~~~~~~~~~~若(v_i,v_j)或<v_i.v_j>是E(G)中的边\\\\
0或∞,~~~~~~~若(v_i,v_j)或<v_i.v_j>不是E(G)中的边\\
\end{cases}</script><p>举例如下：</p>
<pre class="mermaid">graph LR;
A((1))
B((2))
C((3))
D((4))
A--5-->B
A--8-->C
C--10-->D
D--21-->A</pre>

<script type="math/tex; mode=display">
A_2=\left[
\matrix{
 ∞ & 5 & 8 & ∞\\
 ∞ & ∞ & ∞ & ∞\\
 ∞ & ∞ & ∞ & 10\\
 21 & ∞ & ∞ & ∞\\
}
\right]</script><p>存储结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertextNum 100							<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;							<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;								<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VertexType Vex[MaxVertextNum];						<span class="comment">//顶点表</span></span><br><span class="line">    Edgetype Edge[MaxVertextNum][MaxVertextNum];		<span class="comment">//邻接矩阵，边表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;									<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<h4 id="（2）邻接表法"><a href="#（2）邻接表法" class="headerlink" title="（2）邻接表法"></a>（2）邻接表法</h4><ul>
<li>无向图：存储空间O(|V|+2|E|)</li>
<li>有向图：存储空间O(|V|+|E|)</li>
</ul>
<p>顶点表结点结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">顶点域</th>
<th style="text-align:center">边表头指针</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">data</td>
<td style="text-align:center">firstarc</td>
</tr>
</tbody>
</table>
</div>
<p>边表结点结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">邻接点域</th>
<th style="text-align:center">指针域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">adjvex</td>
<td style="text-align:center">nextarc</td>
</tr>
</tbody>
</table>
</div>
<p>存储结构定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100							<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;								<span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex;									<span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next;						<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;							//网的边权值</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;							<span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;							<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;								<span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdiList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdiList vertices;							<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum,arcnum;							<span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125;ALGraph;										<span class="comment">//ALGraph是以邻接表存储的图的类型</span></span><br></pre></td></tr></table></figure>
<h4 id="（3）十字链表法（有向图）"><a href="#（3）十字链表法（有向图）" class="headerlink" title="（3）十字链表法（有向图）"></a>（3）十字链表法（有向图）</h4><p>图的十字链表表示不唯一，但一个十字链表表示确定一个图</p>
<p>弧结点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">tailvex</th>
<th style="text-align:center">headvex</th>
<th style="text-align:center">hlink</th>
<th style="text-align:center">tlink</th>
<th style="text-align:center">info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>顶点结点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">data</th>
<th style="text-align:center">firstin</th>
<th style="text-align:center">firstout</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/十字链表法.png" style="zoom:80%;"></p>
<h4 id="（4）邻接多重表（无向图）"><a href="#（4）邻接多重表（无向图）" class="headerlink" title="（4）邻接多重表（无向图）"></a>（4）邻接多重表（无向图）</h4><p>顶点结点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">mark</th>
<th style="text-align:center">ivex</th>
<th style="text-align:center">ilink</th>
<th style="text-align:center">jvex</th>
<th style="text-align:center">jlink</th>
<th style="text-align:center">info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>弧顶点</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">data</th>
<th style="text-align:center">firstedge</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/邻接多重表.png" style="zoom:80%;"></p>
<h3 id="3-基本算法实现"><a href="#3-基本算法实现" class="headerlink" title="3.基本算法实现"></a>3.基本算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Adjacent</span>(G,x,y)：判断图G是否存在边&lt;x,y&gt;或(x,y)。</span><br><span class="line"><span class="built_in">Neighbors</span>(G,x)：列出图G中与结点x邻接的边。</span><br><span class="line"><span class="built_in">InsertVertex</span>(G,x)：在图G中插入顶点x。</span><br><span class="line"><span class="built_in">DeleteVertex</span>(G,x)：在图G中删除顶点x。</span><br><span class="line"><span class="built_in">AddEdge</span>(G,x,y)：若无边边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边。</span><br><span class="line"><span class="built_in">RemoveEdge</span>(G,x,y)：若无边边(x,y)或有向边&lt;x,y&gt;存在，则向图G中删除该边。 </span><br><span class="line"><span class="built_in">FirstNeighbor</span>(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回<span class="number">-1</span>。</span><br><span class="line"><span class="built_in">NextNeighbor</span>(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回<span class="number">-1</span>。</span><br><span class="line"><span class="built_in">Get_edge_value</span>(G,x,y)：获取图中G中边(x,y)或&lt;x,y&gt;对应的权值。</span><br><span class="line"><span class="built_in">Set_edge_value</span>(G,x,y,v)：设置图中G中边(x,y)或&lt;x,y&gt;对应的权值为v。</span><br></pre></td></tr></table></figure>
<h2 id="第二节图的遍历算法"><a href="#第二节图的遍历算法" class="headerlink" title="第二节图的遍历算法"></a>第二节图的遍历算法</h2><h3 id="1-广度优先搜索（BFS）"><a href="#1-广度优先搜索（BFS）" class="headerlink" title="1.广度优先搜索（BFS）"></a>1.广度优先搜索（BFS）</h3><ul>
<li>邻接表：空间复杂度O(|V|)    时间复杂度O(|V|+|E|)</li>
<li>邻接矩阵：空间复杂度O(|V|)    时间复杂度O(|V|^2)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];				<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;					<span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i] = FALSE;					<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);							<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;++i)				<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])						<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            <span class="built_in">BFS</span>(G,i);						<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;					<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);								<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;						<span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,v);							<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">osEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);						<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w = <span class="built_in">NextNeighbor</span>(G,v,w))	<span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;				<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);					<span class="comment">//访问顶点w</span></span><br><span class="line">                wisited[w] = TRUE;			<span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w);				<span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-深度优先搜索"><a href="#2-深度优先搜索" class="headerlink" title="2.深度优先搜索"></a>2.深度优先搜索</h3><ul>
<li>邻接表：空间复杂度O(|V|)    时间复杂度O(|V|+|E|)</li>
<li>邻接矩阵：空间复杂度O(|V|)    时间复杂度O(|V|^2)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];				<span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;					<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">        visited[v] = FALSE;					<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v&lt;G.vexnum;++v)				<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;					<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);								<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;						<span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w = <span class="built_in">FirstNeighbor</span>(G,v);w&gt;=<span class="number">0</span>;w = <span class="built_in">NextNeighbor</span>(G,v,w))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;					<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三节最小生成树"><a href="#第三节最小生成树" class="headerlink" title="第三节最小生成树"></a>第三节最小生成树</h2><h3 id="1-性质"><a href="#1-性质" class="headerlink" title="1.性质"></a>1.性质</h3><ul>
<li>最小生成树不是唯一的，即最小生成树的树形不唯一。当图G中的个边权值互不相等时，G的最小生成树时唯一的；若无向连通图G的边数比顶点数少1，即G本身就是一棵树，最小生成树就是它本身。</li>
<li>最小生成树的边的权值之和总是唯一的</li>
<li>最小生成树的边数为顶点数-1</li>
</ul>
<h3 id="2-普利姆算法（稠密图）"><a href="#2-普利姆算法（稠密图）" class="headerlink" title="2.普利姆算法（稠密图）"></a>2.普利姆算法（稠密图）</h3><script type="math/tex; mode=display">
时间复杂度：O(|V|^2)</script><p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/普利姆.png" style="zoom:80%;"></p>
<h3 id="3-克鲁斯卡尔算法（稀疏图）"><a href="#3-克鲁斯卡尔算法（稀疏图）" class="headerlink" title="3.克鲁斯卡尔算法（稀疏图）"></a>3.克鲁斯卡尔算法（稀疏图）</h3><script type="math/tex; mode=display">
时间复杂度：O(|E|log|E|)</script><p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/克鲁斯卡尔.png" style="zoom:80%;"></p>
<h2 id="第四节最短路径、拓扑排序和关键路径"><a href="#第四节最短路径、拓扑排序和关键路径" class="headerlink" title="第四节最短路径、拓扑排序和关键路径"></a>第四节最短路径、拓扑排序和关键路径</h2><h3 id="1-最短路径"><a href="#1-最短路径" class="headerlink" title="1.最短路径"></a>1.最短路径</h3><h4 id="（1）Dijkstra算法-只适合正数"><a href="#（1）Dijkstra算法-只适合正数" class="headerlink" title="（1）Dijkstra算法(只适合正数)"></a>（1）Dijkstra算法(只适合正数)</h4><script type="math/tex; mode=display">
时间复杂度：O(|V|^2)</script><p>dist[]：记录从源点v0到其他个顶点当前的最短路径长度。</p>
<p>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。</p>
<p><img src="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%9B%BE/Dijkstra.png" style="zoom:80%;"></p>
<h4 id="（2）Floyd算法"><a href="#（2）Floyd算法" class="headerlink" title="（2）Floyd算法"></a>（2）Floyd算法</h4><script type="math/tex; mode=display">
时间复杂度：O(|V|^3)~~~~~~~~
空间复杂度：O(|V|^2)</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）有向无环图DAG图"><a href="#（3）有向无环图DAG图" class="headerlink" title="（3）有向无环图DAG图"></a>（3）有向无环图DAG图</h4><p>用来描述公共子式的表达式的有效工具</p>
<h3 id="2-拓扑排序-AOV网"><a href="#2-拓扑排序-AOV网" class="headerlink" title="2.拓扑排序(AOV网)"></a>2.拓扑排序(AOV网)</h3><pre class="mermaid">graph LR;
A((1))
B((2))
C((3))
D((4))
E((5))
A-->B
A-->D
B-->C
B-->D
D-->C
C-->E
D-->E</pre>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">结点号</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">初始入度</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第一轮</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第二轮</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">第三轮</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">第四轮</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">第五轮</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">
\begin{flalign}
&邻接表时间复杂度：O(|V|+|E|)\\
&邻接矩阵时间复杂度：O(|V|^2)
\end{flalign}</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);							<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Push</span>(S,i);						<span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;							<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;						<span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        <span class="built_in">Pop</span>(S,i);							<span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++] = i;					<span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p = G.vertices[i].firstarc;p;p = p-&gt;nextarc)&#123;		</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度-1，并且将入度减为0的顶点压入栈S</span></span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">                <span class="built_in">Push</span>(S,v);					<span class="comment">//入度为0，则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">if</span>(count&lt;G.vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-关键路径-AOE网"><a href="#3-关键路径-AOE网" class="headerlink" title="3.关键路径(AOE网)"></a>3.关键路径(AOE网)</h3><p>\begin{flalign}<br>&amp;（1）事件v_k的最早发生时间ve(k)\\<br>&amp;指从源点v_1到顶点v_k的最长路径的长度。事件v_k的最早发生时间决定了所有从v_k开始的活动能够开工的最早时间。\\<br>&amp;（2）事件v_k的最迟发生时间vl(k)\\<br>&amp;指在不推迟整个工程完成的前提下，即保证它的后继时间v_j在其最迟发生时间vl(j)能够发生时，该事件最迟必须发生的时间。\\<br>&amp;（3）活动a_i的最早发生时间e(i)\\<br>&amp;指该活动弧的起点所表示的时间的最早发生时间\\<br>&amp;（4）活动a_i的最迟发生时间l(i)\\<br>&amp;指该活动弧的终点所表示时间的最迟发生时间与该活动所需时间之差。\\<br>\end{flalign}</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">数据结构-第七章树和二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-23 22:47:43" itemprop="dateCreated datePublished" datetime="2023-04-23T22:47:43+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 00:16:50" itemprop="dateModified" datetime="2023-04-26T00:16:50+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第七章树和二叉树" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第七章树和二叉树"><a href="#第七章树和二叉树" class="headerlink" title="第七章树和二叉树"></a>第七章树和二叉树</h1><h2 id="第一节树的概念"><a href="#第一节树的概念" class="headerlink" title="第一节树的概念"></a>第一节树的概念</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​    是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一棵非空树中应满足：</p>
<ul>
<li>有且仅有一个特定的称为根的结点；</li>
<li>当n&gt;1时，其余结点可分为m（m＞0）个互不相交的有限集，其中每个集合本身又是一棵树，并且成为根的子树</li>
</ul>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><ul>
<li>树的根结点没有前驱，除根节点外的所有结点有且只有一个前驱；</li>
<li>树中所有结点可以由零个或多个后继</li>
</ul>
<h3 id="3-基本性质"><a href="#3-基本性质" class="headerlink" title="3.基本性质"></a>3.基本性质</h3><p>\begin{flalign}<br>&amp;1)树中的结点数等于所有结点的度数之和+1&amp;&amp;\\<br>&amp;2)度为m的树中第i层上至多有m^{i-1}个结点（i≥1）\\<br>&amp;3)高度为h的m叉树至多有(m^h-1)/(m-1)个结点\\<br>&amp;4)有n结点的m叉树最小高度为\lceil log_m[n(m-1)+1] \rceil \\<br>\end{flalign}</p>
<h3 id="4-存储结构"><a href="#4-存储结构" class="headerlink" title="4.存储结构"></a>4.存储结构</h3><p>（1）双亲表示法</p>
<pre class="mermaid">graph TB;
R((R))
A((A))
B((B))
C((C))
D((D))
E((E))
F((F))
G((G))
H((H))
K((K))
R-->A
R-->B
R-->C
A-->D
A-->E
C-->F
F-->G
F-->H
F-->K</pre>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">data</th>
<th style="text-align:center">parent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">R</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">D</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">F</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">G</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">H</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">K</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
</div>
<p>（2）孩子表示法</p>
<p>将每个节点的孩子结点都用单链表链接起来形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点链表为空表）；</p>
<p>这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。</p>
<p>（3）孩子兄弟表示法</p>
<p>优点：方便地实现树转换为二叉树的操作，易于查找结点的孩子等；</p>
<p>缺点：从当前结点查找其双亲结点比较麻烦</p>
<p>①在兄弟结点之间加一条线；</p>
<p>②对每个结点，只保留它与i一个孩子的连线，而与其他孩子 连线全部抹掉；</p>
<p>③以树根为轴心，顺时针旋转45°。</p>
<h3 id="5-树、森林与二叉树遍历的对应关系"><a href="#5-树、森林与二叉树遍历的对应关系" class="headerlink" title="5.树、森林与二叉树遍历的对应关系"></a>5.树、森林与二叉树遍历的对应关系</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">树</th>
<th style="text-align:center">森林</th>
<th style="text-align:center">二叉树</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">先根遍历</td>
<td style="text-align:center">先序遍历</td>
<td style="text-align:center">先序遍历</td>
</tr>
<tr>
<td style="text-align:center">后根遍历</td>
<td style="text-align:center">中序遍历</td>
<td style="text-align:center">中序遍历</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第二节二叉树"><a href="#第二节二叉树" class="headerlink" title="第二节二叉树"></a>第二节二叉树</h2><h3 id="1-概念和性质"><a href="#1-概念和性质" class="headerlink" title="1.概念和性质"></a>1.概念和性质</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>​     一棵二叉树是结点的一个有限集合，该集合：</p>
<ul>
<li>​    或者为空；</li>
<li>​    由一个根节点加上两棵别称为左子树和右子树的二叉树组成</li>
</ul>
<p>满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。</p>
<p>完全二叉树：效率很高的数据结构，由满二叉树而引出来的。是一种特殊的完全二叉树。</p>
<p>二叉排序树：左&lt;中&lt;右.</p>
<p>平衡二叉树：左子树与右子树深度之差不超过1。</p>
<h4 id="（2）性质"><a href="#（2）性质" class="headerlink" title="（2）性质"></a>（2）性质</h4><p>\begin{flalign}<br>&amp;1)n_0 = n_2 +1\\<br>&amp;2)非空二叉树上第k层至多有2^{k-1}个结点（k≥1）\\<br>&amp;3)高度为h的二叉树至少有2^h-1个结点（h≥1）\\<br>&amp;4)对完全二叉树按向上到下、从左到右的顺序依次编号1,2,…,n，则有以下关系：\\<br>&amp;~①当i&gt;1时，结点i的双亲的编号是\lfloor i/2 \rfloor，即当i为偶数时，其双亲的编号是i/2，它是双亲的左孩子。当i为奇数时，其双亲的编号是（i-1）/2，它是双亲的右孩子。\\<br>&amp;~②当2i≤n时，结点i的左孩子编号为2i，否则无左孩子。\\<br>&amp;~③当2i+1≤n时，结点i的右孩子编号为2i+1，否则无右孩子。\\<br>&amp;~④结点i所在层次（深度）为\lfloor log_2i \rfloor+1。\\<br>&amp;5)具有n个（n&gt;0）结点的完全二叉树的高度为\lceil log_2(n+1) \rceil 或\lfloor log_2n \rfloor +1。<br>\end{flalign}</p>
<h3 id="2-存储结构和基本算法"><a href="#2-存储结构和基本算法" class="headerlink" title="2.存储结构和基本算法"></a>2.存储结构和基本算法</h3><p>（1）顺序存储结构</p>
<p>（2）链式存储结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">lchild</th>
<th style="text-align:center">data</th>
<th style="text-align:center">rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTree</span>&#123;</span></span><br><span class="line">	ElemType data;  <span class="comment">// 数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTree</span> *<span class="title">lchile</span>,*<span class="title">rchild</span>;</span> <span class="comment">// 左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="第三节二叉树的遍历算法"><a href="#第三节二叉树的遍历算法" class="headerlink" title="第三节二叉树的遍历算法"></a>第三节二叉树的遍历算法</h2><h3 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1.先序遍历"></a>1.先序遍历</h3><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);		<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);	BiTree p = T;	<span class="comment">//初始化栈；p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!<span class="built_in">IsEmpty</span>(S))&#123;		<span class="comment">//栈不空或p不空时一直循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;		<span class="comment">//一路向左</span></span><br><span class="line">            <span class="built_in">visit</span>(p);	<span class="built_in">Push</span>(S,p);	<span class="comment">//访问当前结点，并入栈</span></span><br><span class="line">            p = p-&gt;lchild;		<span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;		<span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            <span class="built_in">Pop</span>(S,p);				<span class="comment">//栈顶元素出栈</span></span><br><span class="line">            p = p-&gt;rchild;			<span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h3><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);		<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);	BiTree p = T;	<span class="comment">//初始化栈；p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p||!<span class="built_in">IsEmpty</span>(S))&#123;		<span class="comment">//栈不空或p不空时一直循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;		<span class="comment">//一路向左</span></span><br><span class="line">            <span class="built_in">Push</span>(S,p);			<span class="comment">//当前结点入栈</span></span><br><span class="line">            p = p-&gt;lchild;		<span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;		<span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            <span class="built_in">Pop</span>(S,p);	<span class="built_in">visit</span>(p);	<span class="comment">//栈顶元素出栈，p赋值为当前结点的右孩子</span></span><br><span class="line">            p = p-&gt;rchild;			<span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h3><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)&#123;</span><br><span class="line">       	<span class="built_in">PostOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);		<span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    BiTree p = T,r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p||!<span class="built_in">IsEmpty</span>(S))&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)&#123;		<span class="comment">//走到最左边</span></span><br><span class="line">            <span class="built_in">Push</span>(S,p);			<span class="comment">//当前结点入栈</span></span><br><span class="line">            p = p-&gt;lchild;		<span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;		<span class="comment">//向右</span></span><br><span class="line">            <span class="built_in">GetTop</span>(S,p);		<span class="comment">//读栈顶结点（非出栈）</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild&amp;&amp;p-&gt;rchild!=r)		<span class="comment">//若右子树存在，且未被访问过</span></span><br><span class="line">                p = p-&gt;rchild;		<span class="comment">//转向右</span></span><br><span class="line">            <span class="keyword">else</span>&#123;	<span class="comment">//否则，弹出结点并访问</span></span><br><span class="line">                <span class="built_in">Pop</span>(S,p);			 <span class="comment">//将结点弹出</span></span><br><span class="line">                <span class="built_in">visit</span>(p-&gt;data);		 <span class="comment">//访问该结点</span></span><br><span class="line">                r = p;				<span class="comment">//记录最近访问过的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;			<span class="comment">//结点访问完后，重置p指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-层次遍历"><a href="#4-层次遍历" class="headerlink" title="4.层次遍历"></a>4.层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);				<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,T);				<span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;			<span class="comment">//队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,p);			<span class="comment">//队头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);				<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,p-&gt;lchild);	<span class="comment">//左子树不空，则左子树根结点入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,p-&gt;rchild);	<span class="comment">//右子树不空，则右子树根结点入队</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四节线索二叉树"><a href="#第四节线索二叉树" class="headerlink" title="第四节线索二叉树"></a>第四节线索二叉树</h2><p>是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到集中遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前去和直接后继。</p>
<p>目的：为了加快查找结点前驱和后继的速度。</p>
<p>空指针 = 线索数 = n+1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">lchild</th>
<th style="text-align:center">ltag</th>
<th style="text-align:center">data</th>
<th style="text-align:center">rtag</th>
<th style="text-align:center">rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>ltag</p>
<ul>
<li>​    0    lchild域指示结点的左孩子</li>
<li>​    1    lchild域指示结点的前驱</li>
</ul>
<p>rtag</p>
<ul>
<li>​    0    rchild域指示结点的右孩子</li>
<li>​    1    rchild域指示结点的前驱</li>
</ul>
<p>存储结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;						<span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild,*rchild;		<span class="comment">//左、右孩子指针</span></span><br><span class="line">    <span class="type">int</span> ltag,rtag;						<span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
<h2 id="第五节哈夫曼树"><a href="#第五节哈夫曼树" class="headerlink" title="第五节哈夫曼树"></a>第五节哈夫曼树</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h3><p>树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记作：</p>
<script type="math/tex; mode=display">
WPL = \sum_{i=1}^nw_il_i</script><p>举例如下哈夫曼树，WPL = (4+2)<em>3+5</em>2+7*1 = 35</p>
<pre class="mermaid">graph TB;
A((A))
B((B))
C((C))
D((D:7))
E((E:5))
F((F:2))
G((G:4))
A-->D
A-->B
B-->C
B-->E
C-->G
C-->F</pre>

<h3 id="2-编码问题（左0右1）"><a href="#2-编码问题（左0右1）" class="headerlink" title="2.编码问题（左0右1）"></a>2.编码问题（左0右1）</h3><pre class="mermaid">graph TB;
A((A))
B((B))
C((C))
D((D:7))
E((E:5))
F((F:2))
G((G:4))
A--1-->D
A--0-->B
B--0-->C
B--1-->E
C--0-->G
C--1-->F</pre>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
<th style="text-align:center">F</th>
<th style="text-align:center">G</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">01</td>
<td style="text-align:center">001</td>
<td style="text-align:center">000</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" class="post-title-link" itemprop="url">数据结构-第六章递归算法和广义表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-23 22:46:58 / 修改时间：22:58:15" itemprop="dateCreated datePublished" datetime="2023-04-23T22:46:58+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%85%AD%E7%AB%A0%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第六章递归算法和广义表" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第六章递归算法和广义表"><a href="#第六章递归算法和广义表" class="headerlink" title="第六章递归算法和广义表"></a>第六章递归算法和广义表</h1><h2 id="第一节递归算法"><a href="#第一节递归算法" class="headerlink" title="第一节递归算法"></a>第一节递归算法</h2><h3 id="1-递归算法概念"><a href="#1-递归算法概念" class="headerlink" title="1.递归算法概念"></a>1.递归算法概念</h3><p>​    是一种直接或者间接调用自身函数或者方法的算法。说简单点就是程序自身的调用。</p>
<h3 id="2-递归算法设计"><a href="#2-递归算法设计" class="headerlink" title="2.递归算法设计"></a>2.递归算法设计</h3><h4 id="（1）阶乘"><a href="#（1）阶乘" class="headerlink" title="（1）阶乘"></a>（1）阶乘</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fac</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">f</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">f</span>(<span class="number">5</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//120</span></span><br></pre></td></tr></table></figure>
<h4 id="（2）斐波那契数列"><a href="#（2）斐波那契数列" class="headerlink" title="（2）斐波那契数列"></a>（2）斐波那契数列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">fib</span>(<span class="number">10</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//55</span></span><br></pre></td></tr></table></figure>
<h4 id="（3）杨辉三角的取值"><a href="#（3）杨辉三角的取值" class="headerlink" title="（3）杨辉三角的取值"></a>（3）杨辉三角的取值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>||n == m )<span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> func(m<span class="number">-1</span>,n)+func(m<span class="number">-1</span>,n<span class="number">-1</span>);<span class="comment">//核心代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m,i,j;</span><br><span class="line">    m=<span class="number">6</span>;<span class="comment">//打印前6行杨辉三角</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m-i;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>,func(i,j));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）汉诺塔"><a href="#（4）汉诺塔" class="headerlink" title="（4）汉诺塔"></a>（4）汉诺塔</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> A, <span class="type">char</span> B, <span class="type">char</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//圆盘只有一个时，只需将其从A塔移到C塔</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; A &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; C &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Move</span>(n - <span class="number">1</span>, A, C, B);<span class="comment">//递归，把A塔上编号1~n-1的圆盘移到B上，以C为辅助塔</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; A &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; C &lt;&lt; endl;<span class="comment">//把A塔上编号为n的圆盘移到C上</span></span><br><span class="line">        <span class="built_in">Move</span>(n - <span class="number">1</span>, B, A, C);<span class="comment">//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Move</span>(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二节广义表"><a href="#第二节广义表" class="headerlink" title="第二节广义表"></a>第二节广义表</h2><h3 id="1-广义表概念"><a href="#1-广义表概念" class="headerlink" title="1.广义表概念"></a>1.广义表概念</h3><p>​    是一种非线性的数据结构，它的表元素可以是原子或者广义表的一种线性表的扩展结构。</p>
<ul>
<li>​    广义表的长度：表中最上层元素的个数</li>
<li>​    广义表的深度：表中括号的最大层数</li>
<li>​    表头和表尾：当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E=()	<span class="comment">//E是一个空表，其长度为0，其深度为1</span></span><br><span class="line">L=(a，b)	<span class="comment">//L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表，其深度为1</span></span><br><span class="line">A=(x，L)=(x，(a，b))	<span class="comment">//A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L，其深度为2</span></span><br><span class="line">B=(A，y)=((x，(a，b))，y)	<span class="comment">//B是长度为2的广义表，第一个元素是子表A，第二个元素是原子y，其深度为3</span></span><br><span class="line">C=(A，B)=((x，(a，b))，((x，(a，b))，y))	<span class="comment">//C的长度为2，两个元素都是子表，其深度为4</span></span><br><span class="line">D=(a，D)=(a，(a，(a，(…))))	<span class="comment">//D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表，其深度为∞</span></span><br></pre></td></tr></table></figure>
<h3 id="2-广义表存储结构和操作实现"><a href="#2-广义表存储结构和操作实现" class="headerlink" title="2.广义表存储结构和操作实现"></a>2.广义表存储结构和操作实现</h3><h4 id="（1）广义表结点的代码结构"><a href="#（1）广义表结点的代码结构" class="headerlink" title="（1）广义表结点的代码结构"></a>（1）广义表结点的代码结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义广义表的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">GList</span>&#123;</span><br><span class="line">	NodeTag tag; <span class="comment">//用以区分是原子结点还是子表结点</span></span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		DataType data; <span class="comment">//用以存放原子结点值，其类型由用户自定义</span></span><br><span class="line">		GList *slink; <span class="comment">//指向子表的指针</span></span><br><span class="line">	&#125;;</span><br><span class="line">	GList *next; <span class="comment">//指向下一个表结点</span></span><br><span class="line">&#125; *GListPtr;</span><br></pre></td></tr></table></figure>
<h4 id="（2）求表头、表尾"><a href="#（2）求表头、表尾" class="headerlink" title="（2）求表头、表尾"></a>（2）求表头、表尾</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求广义表L的表头，并返回表头指针*/</span></span><br><span class="line"><span class="function">GList <span class="title">Head</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)					<span class="comment">//空表无表头</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;tag == ATOM)				<span class="comment">//原子不是表</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> L-&gt;atom_htp.htp.hp;	<span class="comment">//返回表头指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求广义表L的表尾，并返回表尾指针*/</span></span><br><span class="line"><span class="function">GList <span class="title">Tail</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)					<span class="comment">//空表无表尾</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;tag == ATOM)				<span class="comment">//原子不是表</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> L-&gt;atom_htp.htp.tp;	<span class="comment">//返回表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）求长度、深度"><a href="#（3）求长度、深度" class="headerlink" title="（3）求长度、深度"></a>（3）求长度、深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求广义表长度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	GLNode* s;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;					<span class="comment">//空表长度为0</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;tag == ATOM)				<span class="comment">//原子不是表</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	s = L;</span><br><span class="line">	<span class="keyword">while</span> (s != <span class="literal">NULL</span>) &#123;				<span class="comment">//统计最上层表的长度</span></span><br><span class="line">		k++;</span><br><span class="line">		s = s-&gt;atom_htp.htp.tp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*求广义表的深度*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> d, max;</span><br><span class="line">	GLNode* s;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;					<span class="comment">//空表深度为1</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;tag == ATOM)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;					<span class="comment">//原子深度为0</span></span><br><span class="line">	s = L;</span><br><span class="line">	<span class="keyword">while</span> (s != <span class="literal">NULL</span>) &#123;				<span class="comment">//求每个子表的深度的最大值</span></span><br><span class="line">		d = <span class="built_in">Depth</span>(s-&gt;atom_htp.htp.hp);</span><br><span class="line">		<span class="keyword">if</span> (d &gt; max)</span><br><span class="line">			max = d;</span><br><span class="line">		s = s-&gt;atom_htp.htp.tp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (max + <span class="number">1</span>);				<span class="comment">//表的深度等于最深子表的深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintGList</span><span class="params">(GListPtr gl)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(gl != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(gl-&gt;tag == list)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(gl-&gt;slink == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">PrintGList</span>(gl-&gt;slink); <span class="comment">//递归调用输出子表</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, gl-&gt;data); <span class="comment">//输出结点数据域值</span></span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(gl-&gt;tag == list)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(gl-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">			<span class="built_in">PrintGList</span>(gl-&gt;next); <span class="comment">//递归调用输出下一个节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）统计原子个数"><a href="#（4）统计原子个数" class="headerlink" title="（4）统计原子个数"></a>（4）统计原子个数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*统计广义表中原子结点数目*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CountAtom</span><span class="params">(GList L)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n1, n2;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;							<span class="comment">//空表中没有原子</span></span><br><span class="line">	<span class="keyword">if</span> (L-&gt;tag == ATOM)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;							<span class="comment">//L指向单个原子</span></span><br><span class="line">	n1 = <span class="built_in">CountAtom</span>(L-&gt;atom_htp.htp.hp);		<span class="comment">//统计表头中的原子数目</span></span><br><span class="line">	n2 = <span class="built_in">CountAtom</span>(L-&gt;atom_htp.htp.tp);		<span class="comment">//统计表尾中的原子数目</span></span><br><span class="line">	<span class="keyword">return</span> (n1 + n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（5）广义表的复制"><a href="#（5）广义表的复制" class="headerlink" title="（5）广义表的复制"></a>（5）广义表的复制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*复制广义表*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CopyGList</span><span class="params">(GList S, GList* T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S == <span class="literal">NULL</span>) &#123;				<span class="comment">//复制空表</span></span><br><span class="line">		*T = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	*T = (GLNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(GLNode));</span><br><span class="line">	<span class="keyword">if</span> (*T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	(*T)-&gt;tag = S-&gt;tag;</span><br><span class="line">	<span class="keyword">if</span> (S-&gt;tag == ATOM)</span><br><span class="line">		(*T)-&gt;atom_htp.atom = S-&gt;atom_htp.atom;		<span class="comment">//复制单个原子</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*复制表头*/</span></span><br><span class="line">		<span class="built_in">CopyGList</span>(S-&gt;atom_htp.htp.hp, &amp;((*T)-&gt;atom_htp.htp.hp));</span><br><span class="line">		<span class="comment">/*复制表尾*/</span></span><br><span class="line">		<span class="built_in">CopyGList</span>(S-&gt;atom_htp.htp.tp, &amp;((*T)-&gt;atom_htp.htp.tp));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">数据结构-第五章数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-23 22:43:47 / 修改时间：22:58:00" itemprop="dateCreated datePublished" datetime="2023-04-23T22:43:47+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%95%B0%E7%BB%84/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第五章数组" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>115</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第五章数组"><a href="#第五章数组" class="headerlink" title="第五章数组"></a>第五章数组</h1><h2 id="第一节数组的概念"><a href="#第一节数组的概念" class="headerlink" title="第一节数组的概念"></a>第一节数组的概念</h2><h3 id="1-数据概念"><a href="#1-数据概念" class="headerlink" title="1.数据概念"></a>1.数据概念</h3><p>​    数组是由n（n≥1）个相同类型的数据元素构成的有限序列</p>
<h3 id="2-数组的实现"><a href="#2-数组的实现" class="headerlink" title="2.数组的实现"></a>2.数组的实现</h3><p>​    以一维数组A[0…n-1]为例，其存储结构关系式为</p>
<script type="math/tex; mode=display">
LOC(a_i) = LOC(a_0)+i*L\quad\quad (0≤i<n)</script><p>​    其中，L时每个数组元素所占的存储单元</p>
<h2 id="第二节特殊矩阵和稀疏矩阵的压缩存储"><a href="#第二节特殊矩阵和稀疏矩阵的压缩存储" class="headerlink" title="第二节特殊矩阵和稀疏矩阵的压缩存储"></a>第二节特殊矩阵和稀疏矩阵的压缩存储</h2><h3 id="1-特殊矩阵的压缩存储"><a href="#1-特殊矩阵的压缩存储" class="headerlink" title="1.特殊矩阵的压缩存储"></a>1.特殊矩阵的压缩存储</h3><h4 id="（1）对称矩阵（1，0）"><a href="#（1）对称矩阵（1，0）" class="headerlink" title="（1）对称矩阵（1，0）"></a>（1）对称矩阵（1，0）</h4><script type="math/tex; mode=display">
k=
\begin{cases}
i(i-1)/2+j-1,\quad\quad i≥j（下三角区和主对角线元素）\\\\
j(j-1)/2+i-1,\quad\quad i<j（上三角区元素a_{ij} = a_{ji}）
\end{cases}</script><h4 id="（2）三角矩阵（1，0）"><a href="#（2）三角矩阵（1，0）" class="headerlink" title="（2）三角矩阵（1，0）"></a>（2）三角矩阵（1，0）</h4><p>下三角矩阵</p>
<script type="math/tex; mode=display">
k=
\begin{cases}
i(i-1)/2+j-1,\quad\quad i≥j（下三角区和主对角线元素）\\\\
n(n+1)/2,\quad\quad~~~~~~~~~~~ i<j（上三角区元素）
\end{cases}</script><p>上三角矩阵</p>
<script type="math/tex; mode=display">
k=
\begin{cases}
(i-1)(2n-i+2)/2+(j-i),\quad\quad i≤j（上三角区和主对角线元素）\\\\
n(n+1)/2,\quad\quad~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ i>j（下三角区元素）
\end{cases}</script><h4 id="（3）三对角矩阵（1，0）"><a href="#（3）三对角矩阵（1，0）" class="headerlink" title="（3）三对角矩阵（1，0）"></a>（3）三对角矩阵（1，0）</h4><script type="math/tex; mode=display">
k = 2i+j-3</script><h3 id="2-稀疏矩阵的压缩存储"><a href="#2-稀疏矩阵的压缩存储" class="headerlink" title="2.稀疏矩阵的压缩存储"></a>2.稀疏矩阵的压缩存储</h3><p>稀疏矩阵压缩存储后便失去了随机存取特性</p>
<script type="math/tex; mode=display">
M=\left[
\matrix{
 4 & 0 & 0 & 0\\
 0 & 0 & 6 & 0\\
 0 & 9 & 0 & 0\\
 0 & 23 & 0 & 0\\
}
\right]</script><p>对应三元组</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">j</th>
<th style="text-align:center">v</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">23</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B8%B2/" class="post-title-link" itemprop="url">数据结构-第四章串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-23 22:43:04 / 修改时间：22:57:45" itemprop="dateCreated datePublished" datetime="2023-04-23T22:43:04+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%B8%B2/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第四章串" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第四章串"><a href="#第四章串" class="headerlink" title="第四章串"></a>第四章串</h1><h2 id="第一节串的概念和存储结构"><a href="#第一节串的概念和存储结构" class="headerlink" title="第一节串的概念和存储结构"></a>第一节串的概念和存储结构</h2><h3 id="1-串的概念"><a href="#1-串的概念" class="headerlink" title="1.串的概念"></a>1.串的概念</h3><p>​    由0个或多个字符组成的有效序列，一般记作</p>
<script type="math/tex; mode=display">
S='a_1a_2a_3...a_n'~~~（n≥0）</script><h3 id="2-串的存储结构和基本算法的实现"><a href="#2-串的存储结构和基本算法的实现" class="headerlink" title="2.串的存储结构和基本算法的实现"></a>2.串的存储结构和基本算法的实现</h3><h4 id="（1）定长顺序存储表示"><a href="#（1）定长顺序存储表示" class="headerlink" title="（1）定长顺序存储表示"></a>（1）定长顺序存储表示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255		<span class="comment">//预定义最大串长255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">char</span> ch[MAXLEN];		<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">	<span class="type">int</span> length;				<span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<h4 id="（2）堆分配存储表示"><a href="#（2）堆分配存储表示" class="headerlink" title="（2）堆分配存储表示"></a>（2）堆分配存储表示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;		<span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;		<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
<h4 id="（3）基本操作"><a href="#（3）基本操作" class="headerlink" title="（3）基本操作"></a>（3）基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StrAssign</span>(&amp;T,chars)：赋值操作。把串T赋值为chars。</span><br><span class="line"><span class="built_in">StrCopy</span>(&amp;T,S)：复制操作。由串S复制得到串T。</span><br><span class="line"><span class="built_in">StrEmpty</span>(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。</span><br><span class="line"><span class="built_in">StrLength</span>(S)：求串长。返回串S的元素个数。</span><br><span class="line"><span class="built_in">ClearString</span>(&amp;S)：清空操作。将S清为空串。</span><br><span class="line"><span class="built_in">Concat</span>(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串</span><br><span class="line"><span class="built_in">SubString</span>(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span><br><span class="line"><span class="built_in">Index</span>(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为<span class="number">0</span>。</span><br><span class="line"><span class="built_in">StrCompare</span>(S,T)：比较操作。若S&gt;T，则返回值&gt;<span class="number">0</span>；若S=T，则返回值=<span class="number">0</span>；若S&lt;T，则返回值&lt;<span class="number">0</span>。</span><br><span class="line"><span class="built_in">DestroyString</span>(&amp;S)：销毁中。将串S销毁。</span><br></pre></td></tr></table></figure>
<h2 id="第二节串的匹配算法"><a href="#第二节串的匹配算法" class="headerlink" title="第二节串的匹配算法"></a>第二节串的匹配算法</h2><h3 id="1-BF算法（简单模式匹配算法）"><a href="#1-BF算法（简单模式匹配算法）" class="headerlink" title="1.BF算法（简单模式匹配算法）"></a>1.BF算法（简单模式匹配算法）</h3><p>时间复杂度：最好O（n），最坏O（nm）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BF</span><span class="params">(string S,string T,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt;= S.<span class="built_in">size</span>() &amp;&amp; j &lt;= T.<span class="built_in">size</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( S[i<span class="number">-1</span>] == T[j<span class="number">-1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;<span class="comment">//i为母串S的匹配失败的位置，j为模式串S的匹配失败的位置，i-j为S第一次匹配位置之前的长度，</span></span><br><span class="line">            <span class="comment">//+2的原因是一个1是本次匹配的开始位置 ，另一个1是下一次匹配的开始位置。</span></span><br><span class="line">            j = <span class="number">1</span>;<span class="comment">//模式串的下一次匹配开始位置依旧是第一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( j &gt; T.<span class="built_in">size</span>() )</span><br><span class="line">        <span class="keyword">return</span> i - T.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    string S,T;</span><br><span class="line">    <span class="keyword">while</span>( <span class="literal">true</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入母串：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;S;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入模式串：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;T;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入在母串中开始寻找的位置（小于等于&quot;</span>&lt;&lt;S.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;）：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;pos;</span><br><span class="line">        <span class="keyword">while</span> ( pos &gt; S.<span class="built_in">size</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;请重新输入在母串中开始寻找的位置（小于等于&quot;</span>&lt;&lt;S.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;）：&quot;</span>;</span><br><span class="line">            cin&gt;&gt;pos;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;模式串在自母串第 &quot;</span>&lt;&lt;pos&lt;&lt;<span class="string">&quot; 位开始出现的位置为 &quot;</span>&lt;&lt;<span class="built_in">BF</span>(S,T,pos)&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-KMP算法"><a href="#2-KMP算法" class="headerlink" title="2.KMP算法"></a>2.KMP算法</h3><h4 id="（1）next数组"><a href="#（1）next数组" class="headerlink" title="（1）next数组"></a>（1）next数组</h4><p>以‘ababa’举例说明：</p>
<ul>
<li>‘a’的前缀和后缀都是空集，最长相等前后缀长度为0；</li>
<li>‘ab’的前缀为{a}，后缀为{b}，{a}且{b}=空集，最长相等前后缀长度为0；</li>
<li>‘aba’的前缀是{a,ab}，后缀是{a,ba}，{a,ab}且{a,ba}={a}，最长相等前后缀长度为1；</li>
<li>‘abab’的前缀是{a,ab,aba}，后缀是{a,ba,bab}，{a,ab,aba}且{a,ba,bab}={a}，最长相等前后缀长度为1；</li>
<li>‘ababa’的前缀是{a,ab,aba,abab}，后缀是{a,ba,aba,baba}，{a,ab,aba,abab}且{a,ba,aba,baba}={a,aba}，最长相等前后缀长度为3；</li>
</ul>
<p>时间复杂度：O（n+m）；优点：主串不回溯</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（2）nextval数组"><a href="#（2）nextval数组" class="headerlink" title="（2）nextval数组"></a>（2）nextval数组</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">j</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模式串T</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
<td style="text-align:center">a</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">nextval</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">数据结构-第三章栈与队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-04-23 22:41:27 / 修改时间：22:45:54" itemprop="dateCreated datePublished" datetime="2023-04-23T22:41:27+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第三章栈与队列" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第三章栈与队列"><a href="#第三章栈与队列" class="headerlink" title="第三章栈与队列"></a>第三章栈与队列</h1><h2 id="第三节堆栈和队列的应用"><a href="#第三节堆栈和队列的应用" class="headerlink" title="第三节堆栈和队列的应用"></a>第三节堆栈和队列的应用</h2><h3 id="1-表达式求值"><a href="#1-表达式求值" class="headerlink" title="1.表达式求值"></a>1.表达式求值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="comment">//链栈存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;Node, * LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈初始化</span></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;   <span class="comment">//构造空栈，栈顶指针置空</span></span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈入栈</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span> </span>&#123;<span class="comment">//栈顶插入元素e</span></span><br><span class="line">    LinkStack p = <span class="keyword">new</span> Node;    <span class="comment">//生成新节点</span></span><br><span class="line">    p-&gt;data = e;   <span class="comment">//新节点数据域置为e</span></span><br><span class="line">    p-&gt;next = S;   <span class="comment">//将新节点插入栈顶</span></span><br><span class="line">    S = p; <span class="comment">//修改栈顶指针为p</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的出栈</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="comment">//栈为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    LinkStack p;   <span class="comment">//定义临时链栈</span></span><br><span class="line">    e = S-&gt;data;   <span class="comment">//将栈顶元素赋值给e</span></span><br><span class="line">    p = S; <span class="comment">//临时存储栈顶空间，以备释放</span></span><br><span class="line">    S = S-&gt;next;   <span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">delete</span> p;  <span class="comment">//删除栈顶指针</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>) <span class="comment">//栈非空</span></span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断读入的字符ch是否为运算符</span></span><br><span class="line"><span class="function">Status <span class="title">In</span><span class="params">(SElemType ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span> || ch == <span class="string">&#x27;(&#x27;</span> || ch == <span class="string">&#x27;)&#x27;</span>||ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断运算符栈顶元素与读入运算符ch的优先级</span></span><br><span class="line"><span class="function">SElemType <span class="title">Precede</span><span class="params">(SElemType a, SElemType b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;+&#x27;</span> || a == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;+&#x27;</span> || b == <span class="string">&#x27;-&#x27;</span> || b == <span class="string">&#x27;#&#x27;</span> || b == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;*&#x27;</span> || a == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&lt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运算函数</span></span><br><span class="line"><span class="function">SElemType <span class="title">Operate</span><span class="params">(SElemType a, SElemType t, SElemType b)</span> </span>&#123;<span class="comment">//进行运算的函数</span></span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法表达式求值的优先算法，设OPTR和OPND分别为运算符栈和操作数栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EvaluateExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkStack OPND, OPTR;  <span class="comment">//定义栈</span></span><br><span class="line">    SElemType ch, t,t1,t2;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPND);   <span class="comment">//初始化操作数栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR);   <span class="comment">//初始化运算符栈</span></span><br><span class="line">    <span class="built_in">Push</span>(OPTR,<span class="string">&#x27;#&#x27;</span>);    <span class="comment">//入栈</span></span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>) &#123;<span class="comment">//表达式没有扫描完毕或者OPTR栈顶不为‘#’时执行</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">In</span>(ch)) &#123; <span class="comment">//ch不是运算符</span></span><br><span class="line">            <span class="built_in">Push</span>(OPND, ch-<span class="string">&#x27;0&#x27;</span>);    <span class="comment">//进入OPND栈</span></span><br><span class="line">            cin &gt;&gt; ch; <span class="comment">//读取下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), ch)) &#123;   <span class="comment">//比较OPTR栈顶元素和ch的优先级</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Push</span>(OPTR, ch);    <span class="comment">//将ch压入OPTR栈</span></span><br><span class="line">                    cin &gt;&gt; ch; <span class="comment">//读取下一个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                    <span class="built_in">Pop</span>(OPTR, t);  <span class="comment">//弹出OPTR栈顶运算符，赋值给t</span></span><br><span class="line">                    <span class="built_in">Pop</span>(OPND, t2); <span class="comment">//后进先出</span></span><br><span class="line">                    <span class="built_in">Pop</span>(OPND, t1); <span class="comment">//弹出OPND栈顶两个运算数</span></span><br><span class="line">                    <span class="built_in">Push</span>(OPND, <span class="built_in">Operate</span>(t1, t, t2));    <span class="comment">//将运算结果压入OPND栈</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:  <span class="comment">//OPTR栈顶元素是&#x27;(&#x27;且ch是&#x27;)&#x27;</span></span><br><span class="line">                    <span class="built_in">Pop</span>(OPTR, t);  <span class="comment">//弹出栈顶&#x27;(&#x27;</span></span><br><span class="line">                    cin &gt;&gt; ch; <span class="comment">//读取下一个字符</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="type">int</span>)<span class="built_in">GetTop</span>(OPND)&lt;&lt;endl; <span class="comment">//将char转换为int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">EvaluateExpression</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-括号匹配问题"><a href="#2-括号匹配问题" class="headerlink" title="2.括号匹配问题"></a>2.括号匹配问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max_size 200<span class="comment">//栈的最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    datatype zhan[max_size];</span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//栈顶</span></span><br><span class="line">&#125;stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">(stack &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型为datatype的x入栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(stack &amp;st, datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当栈顶和max_size相等时，栈满</span></span><br><span class="line">    <span class="keyword">if</span>(st.top == max_size)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;This stack has already full!&quot;;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        st.zhan[st.top] = x;</span><br><span class="line">        st.top++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">pop</span><span class="params">(stack &amp;st)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st.top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;&quot;This stack is empty!&quot;;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        st.top--;</span><br><span class="line">        <span class="keyword">return</span> st.zhan[st.top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stack s;</span><br><span class="line">    <span class="built_in">initial</span>(s);</span><br><span class="line">    <span class="comment">/*输入字符串，并将字符串放到字符数组中，</span></span><br><span class="line"><span class="comment">    实现能够逐个扫描字符串中的字符，并且不跳过空格符*/</span></span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">200</span>]=&#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(ch,str.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">//flag标志状态 1为括号匹配，0为不匹配</span></span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; ch[i]!=<span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//元素若为&#123;，(，[则入栈</span></span><br><span class="line">        <span class="keyword">if</span>((ch[i] == <span class="string">&#x27;&#123;&#x27;</span> )|| (ch[i] ==<span class="string">&#x27;[&#x27;</span>) || (ch[i] ==<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">            <span class="built_in">push</span>(s, ch[i]);</span><br><span class="line">        &#125;<span class="comment">//元素若为&#125;，)，]则出栈 赋值给a</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((ch[i] == <span class="string">&#x27;&#125;&#x27;</span>) || (ch[i] ==<span class="string">&#x27;]&#x27;</span>) || (ch[i] ==<span class="string">&#x27;)&#x27;</span>))&#123;</span><br><span class="line">            <span class="type">char</span> a;</span><br><span class="line">            a = <span class="built_in">pop</span>(s);</span><br><span class="line">            <span class="comment">//若a与ch[i]匹配，进行下一个字符扫描</span></span><br><span class="line">            <span class="keyword">if</span>((a == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; ch[i] == <span class="string">&#x27;&#125;&#x27;</span>) || (a == <span class="string">&#x27;(&#x27;</span> &amp;&amp; ch[i] == <span class="string">&#x27;)&#x27;</span>) || (a == <span class="string">&#x27;[&#x27;</span> &amp;&amp; ch[i] == <span class="string">&#x27;]&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.top != <span class="number">0</span>)&#123;    <span class="comment">//当左括号多出没有与右括号匹配的时候（如：&quot; &#123;() &quot;）</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;no&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;yes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-迷宫问题（栈，深度检索）"><a href="#3-迷宫问题（栈，深度检索）" class="headerlink" title="3.迷宫问题（栈，深度检索）"></a>3.迷宫问题（栈，深度检索）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROW  6<span class="comment">//行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COL  6<span class="comment">//列</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Maze</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> map[ROW][COL];</span><br><span class="line">&#125;Maze;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Postion</span><span class="comment">//地图中点的坐标,这个栈中存的元素就是点的坐标</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;Postion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Postion DataType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType* top;</span><br><span class="line">    DataType* base;</span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈的初始化</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> DataType[MAX_SIZE];</span><br><span class="line">    <span class="keyword">if</span> (!S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pushStack</span><span class="params">(Stack&amp; S, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *(S.top) = data;</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">popStack</span><span class="params">(Stack&amp; S,DataType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = *(--S.top);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">DataType* <span class="title">getTop</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//注意何时自增何时不自增</span></span><br><span class="line">    <span class="keyword">return</span> S.top<span class="number">-1</span>;<span class="comment">//返回栈顶元素的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回栈中元素个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destoryStack</span><span class="params">(Stack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] S.base;</span><br><span class="line">        S.top = S.base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据给出给出的地图数据初始化结构体地图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initMaze</span><span class="params">(Maze&amp; m, <span class="type">int</span> map[ROW][COL])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">            m.map[i][j] = map[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印迷宫(地图)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMaze</span><span class="params">(Maze&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++) &#123;</span><br><span class="line">            cout &lt;&lt; m.map[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否是有效的入口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidEnter</span><span class="params">(Maze* m,Postion enter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m);<span class="comment">//断言-里面的表达式为0直接终止程序,注意里面的内容是什么</span></span><br><span class="line">    <span class="comment">//只要入口在四个边界上就是合法的,并且是1(道路)</span></span><br><span class="line">    <span class="keyword">if</span> (((enter._x == <span class="number">0</span> || enter._x == ROW - <span class="number">1</span>) || (enter._y == <span class="number">0</span> || enter._y == COL - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前位置是否是出口</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isVaildExit</span><span class="params">(Maze* m, Postion cur, Postion enter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m);</span><br><span class="line">    <span class="comment">//该结点不能是入口点，除了入口点，在边界上就是合法出口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((cur._x != enter._x || cur._y != enter._y) &amp;&amp; ((cur._x == <span class="number">0</span> || cur._x == ROW - <span class="number">1</span>) || (cur._y == <span class="number">0</span> || cur._y == COL - <span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前结点的下一个结点是否能走通-是不是可以走的点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isNextPass</span><span class="params">(Maze* m, Postion cur, Postion next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m);</span><br><span class="line">    <span class="comment">//判断next是不是cur的下一个结点</span></span><br><span class="line">    <span class="comment">//同一行相邻或者同一列相邻</span></span><br><span class="line">    <span class="keyword">if</span> (((next._x == cur._x) &amp;&amp; ((next._y == cur._y + <span class="number">1</span>) || (next._y == cur._y - <span class="number">1</span>)))</span><br><span class="line">        || ((next._y == cur._y) &amp;&amp; ((next._x = cur._x + <span class="number">1</span>) || (next._x = cur._x - <span class="number">1</span>))))</span><br><span class="line">        <span class="comment">//确实是cur的下一个结点(相邻的 )</span></span><br><span class="line">        <span class="comment">//判断这个点是不是在迷宫里</span></span><br><span class="line">        <span class="comment">//合法坐标并且那个位置的值是1</span></span><br><span class="line">        <span class="keyword">if</span> (((next._x &gt;= <span class="number">0</span> &amp;&amp; next._x &lt; ROW) &amp;&amp; (next._y &gt;= <span class="number">0</span> &amp;&amp; next._y &lt; COL))</span><br><span class="line">            &amp;&amp; (m-&gt;map[next._x][next._y] == <span class="number">1</span>))</span><br><span class="line">            <span class="comment">//最后的参数==1，不仅仅是看是否是可以走的位置(道路是1)，</span></span><br><span class="line">            <span class="comment">//同时有了这个我们就不用倒着往往前走了(不走重复的路)，不是有效的结点不只是墙(0)</span></span><br><span class="line">            <span class="comment">//走过的也不是有效结点，直接pop出栈，通过出栈来往前回退</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找迷宫通路</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PassMaze</span><span class="params">(Maze* m, Postion enter, Stack&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m &amp;&amp; <span class="built_in">isValidEnter</span>(m, enter));</span><br><span class="line"></span><br><span class="line">    Postion cur = enter;<span class="comment">//cur存储当前结点</span></span><br><span class="line">    Postion next;<span class="comment">//下一个结点，从入口开始出发向四周移动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先将入口压入栈中</span></span><br><span class="line">    <span class="built_in">pushStack</span>(s, cur);</span><br><span class="line">    m-&gt;map[cur._x][cur._y] = <span class="number">2</span>;<span class="comment">//将入口值改为2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环求解-当栈中还有路径时</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        cur = *<span class="built_in">getTop</span>(s);<span class="comment">//取到栈顶元素</span></span><br><span class="line">        <span class="comment">//判断当前位置是否是出口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isVaildExit</span>(m, cur, enter))<span class="comment">//注意参数传递顺序</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//是出口直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是出口继续在周围判断</span></span><br><span class="line">        <span class="comment">//把cur当前刚才那个位置拿过来向四周判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//先向左判断</span></span><br><span class="line">        next = cur;</span><br><span class="line">        next._y = cur._y - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNextPass</span>(m,cur,next))<span class="comment">//如果下一个结点走得通</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//走得通就走到那个位置-压进栈</span></span><br><span class="line">            <span class="built_in">pushStack</span>(s, next);</span><br><span class="line">            <span class="comment">//走过的位置-标记</span></span><br><span class="line">            m-&gt;map[next._x][next._y] = m-&gt;map[cur._x][cur._y] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//之后</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走不通向另一个方向判断</span></span><br><span class="line">        <span class="comment">//向右走一步</span></span><br><span class="line">        next = cur;</span><br><span class="line">        next._y = cur._y + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNextPass</span>(m, cur, next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushStack</span>(s, next);</span><br><span class="line">            m-&gt;map[next._x][next._y] = m-&gt;map[cur._x][cur._y] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向下走一步</span></span><br><span class="line">        next = cur;</span><br><span class="line">        next._x = cur._x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNextPass</span>(m, cur, next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushStack</span>(s, next);</span><br><span class="line">            m-&gt;map[next._x][next._y] = m-&gt;map[cur._x][cur._y] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向上走一步</span></span><br><span class="line">        next = cur;</span><br><span class="line">        next._x = cur._x - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNextPass</span>(m, cur, next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pushStack</span>(s, next);</span><br><span class="line">            m-&gt;map[next._x][next._y] = m-&gt;map[cur._x][cur._y] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里说明此结点的四个方向都走不通</span></span><br><span class="line">        <span class="comment">//进行回溯</span></span><br><span class="line">        Postion tmp;<span class="comment">//没用 临时接收</span></span><br><span class="line">        <span class="built_in">popStack</span>(s, tmp);<span class="comment">//出栈</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0-墙 1-路</span></span><br><span class="line">    <span class="type">int</span> map[ROW][COL] = &#123;</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">            <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Maze m;<span class="comment">//创建一个迷宫(地图)</span></span><br><span class="line">    <span class="built_in">initMaze</span>(m, map);<span class="comment">//初始化迷宫</span></span><br><span class="line">    <span class="built_in">printMaze</span>(m);<span class="comment">//打印迷宫</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;_______&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迷宫入口</span></span><br><span class="line">    Postion enter;</span><br><span class="line">    enter._x = <span class="number">0</span>;</span><br><span class="line">    enter._y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义栈</span></span><br><span class="line">    Stack s;<span class="comment">//用于保存走过的轨迹，便于回溯</span></span><br><span class="line">    <span class="built_in">initStack</span>(s);<span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">PassMaze</span>(&amp;m, enter, s);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无解&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printMaze</span>(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-调度问题"><a href="#4-调度问题" class="headerlink" title="4.调度问题"></a>4.调度问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_task=<span class="number">10</span>;            	<span class="comment">//最大任务数</span></span><br><span class="line"><span class="type">int</span> n;                           	<span class="comment">//任务数</span></span><br><span class="line"><span class="type">int</span> a[max_task][<span class="number">2</span>];             	<span class="comment">//存储每个作业分别在机器1与机器2上的时间消耗</span></span><br><span class="line"><span class="type">int</span> result[max_task];          		<span class="comment">//存储排列树中的一条路径</span></span><br><span class="line"><span class="type">int</span> best_result[max_task];    		<span class="comment">//存储最优路径</span></span><br><span class="line"><span class="type">int</span> min=INF;                 		<span class="comment">//安排任务最小完成时间</span></span><br><span class="line"><span class="type">int</span> rop[max_task+<span class="number">1</span>];        		<span class="comment">//每个深度对应遍历进度</span></span><br><span class="line"><span class="type">int</span> finish[max_task+<span class="number">1</span>];    			<span class="comment">//每一层消耗时间和</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> result[max_task],<span class="type">int</span> best_result[max_task])</span>   <span class="comment">//复制数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        best_result[i]=result[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">allot_task</span><span class="params">(<span class="type">int</span> depth)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> visited[max_task];    	<span class="comment">//标记已安排任务</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=rop[depth];i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])                 <span class="comment">//寻找该层未访问节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> f1=<span class="number">0</span>;                 	<span class="comment">//在机器一上的完成时间</span></span><br><span class="line">            <span class="type">int</span> f2=<span class="number">0</span>;                  	<span class="comment">//在机器二上的完成时间</span></span><br><span class="line">            rop[depth]=i+<span class="number">1</span>;           	<span class="comment">//更新该层访问进度</span></span><br><span class="line">            visited[i]=<span class="literal">true</span>;         	<span class="comment">//标记作业</span></span><br><span class="line">            result[depth<span class="number">-1</span>]=i;        	<span class="comment">//加入结果序列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    f1+=a[j][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            f2=f1+a[i][<span class="number">1</span>];            	<span class="comment">//该作业完成时间</span></span><br><span class="line">            <span class="keyword">if</span>(f2&lt;finish[depth<span class="number">-1</span>])    	<span class="comment">//该序列执行到此作业消耗时间</span></span><br><span class="line">                f2=finish[depth<span class="number">-1</span>];</span><br><span class="line">            finish[depth]=f2;</span><br><span class="line">            <span class="keyword">if</span>(depth==n)             	<span class="comment">//最后一个作业</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f2&lt;min)</span><br><span class="line">                &#123;</span><br><span class="line">                    min=f2;</span><br><span class="line">                    swap(result,best_result);      <span class="comment">//保存最优序列</span></span><br><span class="line">                &#125;</span><br><span class="line">                visited[i]=<span class="literal">false</span>;</span><br><span class="line">                rop[depth]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(depth&lt;n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f2&gt;min)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[i]=<span class="literal">false</span>;</span><br><span class="line">                    allot_task(depth<span class="number">-1</span>);     <span class="comment">//回溯</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    allot_task(depth+<span class="number">1</span>);      <span class="comment">//继续添加作业</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[rop[depth]<span class="number">-1</span>]=<span class="literal">false</span>;         <span class="comment">//跟换当前层次作业需要把之前作业解标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited[rop[depth]<span class="number">-1</span>]=<span class="literal">false</span>;</span><br><span class="line">    rop[depth]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入任务数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;作业%d分别在机器1与机器2上运行时间：&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    allot_task(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最优调度序列为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,best_result[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n消耗时间为：%d\n&quot;</span>,min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/" class="post-title-link" itemprop="url">数据结构-第一章绪论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-22 18:27:38" itemprop="dateCreated datePublished" datetime="2023-04-22T18:27:38+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-23 22:46:24" itemprop="dateModified" datetime="2023-04-23T22:46:24+08:00">2023-04-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
        </span>
    </span>

  
    <span id="/2023/04/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/" class="post-meta-item leancloud_visitors" data-flag-title="数据结构-第一章绪论" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>839</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第一章绪论"><a href="#第一章绪论" class="headerlink" title="第一章绪论"></a>第一章绪论</h1><h2 id="第一节基本概念"><a href="#第一节基本概念" class="headerlink" title="第一节基本概念"></a>第一节基本概念</h2><p>数据：是信息的载体</p>
<p>数据对象：具有<strong>相同性质</strong>的数据元素的集合，是数据的一个子集</p>
<p>数据元素：是数据的<strong>基本单位</strong>，通常作为一个整体进行考虑和处理</p>
<p>数据项：是构成数据元素的不可分割的<strong>最小单位</strong></p>
<p>数据结构：是指相互之间存在<strong>一种或者多种特定关系</strong>的数据元素的集合</p>
<p>数据类型：原子类型（bool，int…）、结构类型（struct Coordinate{    int x; int y;}; ）</p>
<p>抽象数据类型（ADT）：抽象数据组织及与之相关的操作</p>
<h2 id="第二节三要素"><a href="#第二节三要素" class="headerlink" title="第二节三要素"></a>第二节三要素</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1.逻辑结构"></a>1.逻辑结构</h3><p>集合结构：各个元素同属于一个集合，并无其他关系</p>
<p>线性结构：一对一关系，除第一个元素，所有元素都有唯一前驱；除最后一个元素，所有元素都有唯一后继</p>
<p>树形结构：一对多关系，例：思维导图、文件夹</p>
<p>网状结构：多对多关系，例：道路信息，朋友圈关系</p>
<h3 id="2-数据的运算"><a href="#2-数据的运算" class="headerlink" title="2.数据的运算"></a>2.数据的运算</h3><p>——针对某种逻辑结构，结合实际需求，定义基本运算</p>
<h3 id="3-物理结构（存储结构）"><a href="#3-物理结构（存储结构）" class="headerlink" title="3.物理结构（存储结构）"></a>3.物理结构（存储结构）</h3><p>——如何用计算机表示数据元素的逻辑关系</p>
<p>顺序存储：把<strong>逻辑上相邻的元素存储在物理位置上也相邻的存储单元</strong>中，元素之间的关系由存储单元的邻接关系来体现</p>
<p>链式存储：<strong>逻辑上相邻的元素在物理位置上可以不相邻</strong>，借助指示元素存储地址的<strong>指针</strong>来表示元素之间的逻辑关系</p>
<p>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</p>
<p>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</p>
<p><em>小结：</em></p>
<p><em>1）若采用<strong>顺序存储</strong>，则各个数据元素在物理上必须是<strong>连续的</strong>；若采用<strong>非顺序存储</strong>，则各个数据元素在物理上可以是<strong>离散的</strong></em></p>
<p><em>2）数据的<strong>存储结构</strong>会<strong>影响存储空间分配的方便程度</strong></em></p>
<p><em>3）数据的<strong>存储结构</strong>会<strong>影响对数据运算的速度</strong>，例：在元素之间插入新元素</em></p>
<h2 id="第三节算法"><a href="#第三节算法" class="headerlink" title="第三节算法"></a>第三节算法</h2><p>——是对特定问题求解步骤的一种描述</p>
<p>五个特性：有穷性、确定性、可行性、输入、输出</p>
<p>“好”算法的特性：正确性、可读性、健壮性、高效率和低存储量需求</p>
<h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><p>——时间开销与问题规模n之间的关系</p>
<h3 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.空间复杂度"></a>2.空间复杂度</h3><p>——空间开销（内存开销）与问题规模n之间的关系</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://linvilyao.github.io/2023/04/21/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Linvil Yao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Linvil's Blog">
      <meta itemprop="description" content="Welcome to Linvil's Blog!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Linvil's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/21/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-21 22:22:40" itemprop="dateCreated datePublished" datetime="2023-04-21T22:22:40+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-22 12:35:14" itemprop="dateModified" datetime="2023-04-22T12:35:14+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Hello-World/" itemprop="url" rel="index"><span itemprop="name">Hello World</span></a>
        </span>
    </span>

  
    <span id="/2023/04/21/hello-world/" class="post-meta-item leancloud_visitors" data-flag-title="Hello World" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>367</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Linvil Yao</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"16p3s6fLzeTRVQeTGaUl2ZaN-gzGzoHsz","app_key":"iNfyeaWVmA11Duj7fzr0B1r1","server_url":"https://16p3s6fl.lc-cn-n1-shared.com","security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




<script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"16p3s6fLzeTRVQeTGaUl2ZaN-gzGzoHsz","appKey":"iNfyeaWVmA11Duj7fzr0B1r1","serverURLs":"https://16p3s6fl.lc-cn-n1-shared.com","placeholder":"请写下您的评论","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"el":"#valine-comments","path":"/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://fastly.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});
</script>

</body>
</html>
